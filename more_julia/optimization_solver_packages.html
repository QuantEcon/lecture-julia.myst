
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>9. Solvers, Optimizers, and Automatic Differentiation &#8212; Quantitative Economics with Julia</title>
    <script src="https://unpkg.com/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
    <script src="https://unpkg.com/tippy.js@6.3.1/dist/tippy-bundle.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
    
        <script>
            MathJax = {
            loader: {load: ['[tex]/boldsymbol', '[tex]/textmacros']},
            tex: {
                packages: {'[+]': ['boldsymbol', 'textmacros']},
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                processEscapes: true,
                macros: {
                    "argmax" : "arg\\,max",
                    "argmin" : "arg\\,min",
                    "col"    : "col",
                    "Span"   :  "span",
                    "epsilon": "\\varepsilon",
                    "EE": "\\mathbb{E}",
                    "PP": "\\mathbb{P}",
                    "RR": "\\mathbb{R}",
                    "NN": "\\mathbb{N}",
                    "ZZ": "\\mathbb{Z}",
                    "aA": "\\mathcal{A}",
                    "bB": "\\mathcal{B}",
                    "cC": "\\mathcal{C}",
                    "dD": "\\mathcal{D}",
                    "eE": "\\mathcal{E}",
                    "fF": "\\mathcal{F}",
                    "gG": "\\mathcal{G}",
                    "hH": "\\mathcal{H}",
                }
            },
            svg: {
                fontCache: 'global',
                scale: 0.92,
                displayAlign: "center",
            },
            };
        </script>
    
    
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/quantecon-book-theme.1ef59f8f4e91ec8319176e8479c6af4e.css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">


    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script src="../_static/quantecon-book-theme.15b0c36fffe88f468997fa7b698991d3.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"argmax": "arg\\,max", "argmin": "arg\\,min"}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-svg.js"></script>
    <link rel="canonical" href="https://julia.quantecon.org/more_julia/optimization_solver_packages.html" />
    <link rel="shortcut icon" href="../_static/lectures-favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="10. Visual Studio Code and Other Tools" href="../software_engineering/tools_editors.html" />
    <link rel="prev" title="8. Data and Statistics Packages" href="data_statistical_packages.html" />

<!-- Normal Meta Tags -->
<meta name="author" context="Jesse Perla &amp; Thomas J. Sargent &amp; John Stachurski" />
<meta name="keywords" content="Julia, QuantEcon, Quantitative Economics, Economics, Sloan, Alfred P. Sloan Foundation, Tom J. Sargent, John Stachurski" />
<meta name="description" content=This website presents a set of lectures on quantitative economic modeling, designed and written by Jesse Perla, Thomas J. Sargent and John Stachurski. The language instruction is Julia. />

<!-- Twitter tags -->
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@quantecon" />
<meta name="twitter:title" content="Solvers, Optimizers, and Automatic Differentiation"/>
<meta name="twitter:description" content="This website presents a set of lectures on quantitative economic modeling, designed and written by Jesse Perla, Thomas J. Sargent and John Stachurski. The language instruction is Julia.">
<meta name="twitter:creator" content="@quantecon">
<meta name="twitter:image" content="https://assets.quantecon.org/img/qe-twitter-logo.png">

<!-- Opengraph tags -->
<meta property="og:title" content="Solvers, Optimizers, and Automatic Differentiation" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://julia.quantecon.org/more_julia/optimization_solver_packages.html" />
<meta property="og:image" content="https://assets.quantecon.org/img/qe-og-logo.png" />
<meta property="og:description" content="This website presents a set of lectures on quantitative economic modeling, designed and written by Jesse Perla, Thomas J. Sargent and John Stachurski. The language instruction is Julia." />
<meta property="og:site_name" content="Quantitative Economics with Julia" />
<meta name="theme-color" content="#ffffff" />

  </head>
<body>


    <span id="top"></span>

    <div class="qe-wrapper">

        <div class="qe-main">

            <div class="qe-page" id=more_julia/optimization_solver_packages>

                <div class="qe-page__toc">

                    <div class="inner">

                        
                        <div class="qe-page__toc-header">
                            On this page
                        </div>


                        <nav id="bd-toc-nav" class="qe-page__toc-nav">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#overview">
   9.1. Overview
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#introduction-to-differentiable-programming">
   9.2. Introduction to Differentiable Programming
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#forward-mode-automatic-differentiation">
     9.2.1. Forward-Mode Automatic Differentiation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#forward-mode-with-dual-numbers">
     9.2.2. Forward-Mode with Dual Numbers
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#forwarddiff-jl">
     9.2.3. ForwardDiff.jl
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#zygote-jl">
     9.2.4. Zygote.jl
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#optimization">
   9.3. Optimization
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#optim-jl">
     9.3.1. Optim.jl
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#univariate-functions-on-bounded-intervals">
       9.3.1.1. Univariate Functions on Bounded Intervals
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#unconstrained-multivariate-optimization">
       9.3.1.2. Unconstrained Multivariate Optimization
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#jump-jl">
     9.3.2. JuMP.jl
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#blackboxoptim-jl">
     9.3.3. BlackBoxOptim.jl
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#systems-of-equations-and-least-squares">
   9.4. Systems of Equations and Least Squares
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#roots-jl">
     9.4.1. Roots.jl
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#nlsolve-jl">
     9.4.2. NLsolve.jl
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#leastsquaresoptim-jl">
   9.5. LeastSquaresOptim.jl
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#additional-notes">
   9.6. Additional Notes
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercises">
   9.7. Exercises
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-1">
     9.7.1. Exercise 1
    </a>
   </li>
  </ul>
 </li>
</ul>

                            <p class="logo">
                                
                                    
                                    <a href=https://quantecon.org><img src="../_static/qe-logo-large.png" class="logo" alt="logo"></a>
                                    
                                
                            </p>

                            <p class="powered">Powered by <a href="https://jupyterbook.org/">Jupyter Book</a></p>

                        </nav>

                        <div class="qe-page__toc-footer">
                            
                            
                            <p><a href="#top"><strong>Back to top</strong></a></p>
                        </div>

                    </div>

                </div>

                <div class="qe-page__header">

                    <div class="qe-page__header-copy">

                        <p class="qe-page__header-heading"><a href="../intro.html">Quantitative Economics with Julia</a></p>

                        <p class="qe-page__header-subheading">Solvers, Optimizers, and Automatic Differentiation</p>

                    </div>

                    <p class="qe-page__header-authors">Jesse Perla & Thomas J. Sargent & John Stachurski</p>

                </div> <!-- .page__header -->



                
                <main class="qe-page__content" role="main">
                    
                    <div>
                        
  <div id="qe-notebook-header" style="text-align:right;">
        <a href="https://quantecon.org/" title="quantecon.org">
                <img style="width:250px;display:inline;" src="https://assets.quantecon.org/img/qe-menubar-logo.svg" alt="QuantEcon">
        </a>
</div><div class="tex2jax_ignore mathjax_ignore section" id="solvers-optimizers-and-automatic-differentiation">
<h1><a class="toc-backref" href="#id1"><span class="section-number">9. </span>Solvers, Optimizers, and Automatic Differentiation</a><a class="headerlink" href="#solvers-optimizers-and-automatic-differentiation" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#solvers-optimizers-and-automatic-differentiation" id="id1">Solvers, Optimizers, and Automatic Differentiation</a></p>
<ul>
<li><p><a class="reference internal" href="#overview" id="id2">Overview</a></p></li>
<li><p><a class="reference internal" href="#introduction-to-differentiable-programming" id="id3">Introduction to Differentiable Programming</a></p></li>
<li><p><a class="reference internal" href="#optimization" id="id4">Optimization</a></p></li>
<li><p><a class="reference internal" href="#systems-of-equations-and-least-squares" id="id5">Systems of Equations and Least Squares</a></p></li>
<li><p><a class="reference internal" href="#leastsquaresoptim-jl" id="id6">LeastSquaresOptim.jl</a></p></li>
<li><p><a class="reference internal" href="#additional-notes" id="id7">Additional Notes</a></p></li>
<li><p><a class="reference internal" href="#exercises" id="id8">Exercises</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="overview">
<h2><a class="toc-backref" href="#id2"><span class="section-number">9.1. </span>Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>In this lecture we introduce a few of the Julia libraries that we’ve found particularly useful for quantitative work in economics.</p>
<div class="cell tag_hide-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">LinearAlgebra</span><span class="p">,</span><span class="w"> </span><span class="n">Statistics</span>
<span class="k">using</span><span class="w"> </span><span class="n">ForwardDiff</span><span class="p">,</span><span class="w"> </span><span class="n">Zygote</span><span class="p">,</span><span class="w"> </span><span class="n">Optim</span><span class="p">,</span><span class="w"> </span><span class="n">JuMP</span><span class="p">,</span><span class="w"> </span><span class="n">Ipopt</span><span class="p">,</span><span class="w"> </span><span class="n">BlackBoxOptim</span><span class="p">,</span><span class="w"> </span><span class="n">Roots</span><span class="p">,</span><span class="w"> </span><span class="n">NLsolve</span><span class="p">,</span><span class="w"> </span><span class="n">LeastSquaresOptim</span>
<span class="k">using</span><span class="w"> </span><span class="n">Optim</span><span class="o">:</span><span class="w"> </span><span class="n">converged</span><span class="p">,</span><span class="w"> </span><span class="n">maximum</span><span class="p">,</span><span class="w"> </span><span class="n">maximizer</span><span class="p">,</span><span class="w"> </span><span class="n">minimizer</span><span class="p">,</span><span class="w"> </span><span class="n">iterations</span><span class="w"> </span><span class="c">#some extra functions</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="introduction-to-differentiable-programming">
<h2><a class="toc-backref" href="#id3"><span class="section-number">9.2. </span>Introduction to Differentiable Programming</a><a class="headerlink" href="#introduction-to-differentiable-programming" title="Permalink to this headline">¶</a></h2>
<p>The promise of differentiable programming is that we can move towards taking the derivatives of almost arbitrarily
complicated computer programs, rather than simply thinking about the derivatives of mathematical functions.  Differentiable
programming is the natural evolution of automatic differentiation (AD, sometimes called algorithmic differentiation).</p>
<p>Stepping back, there are three ways to calculate the gradient or Jacobian</p>
<ul class="simple">
<li><p>Analytic derivatives / Symbolic differentiation</p>
<ul>
<li><p>You can sometimes calculate the derivative on pen-and-paper, and potentially simplify the expression.</p></li>
<li><p>In effect, repeated applications of the chain rule, product rule, etc.</p></li>
<li><p>It is sometimes, though not always, the most accurate and fastest option if there are algebraic simplifications.</p></li>
<li><p>Sometimes symbolic integration on the computer a good solution, if the package can handle your functions. Doing algebra by hand is tedious and error-prone, but
is sometimes invaluable.</p></li>
</ul>
</li>
<li><p>Finite differences</p>
<ul>
<li><p>Evaluate the function at least <span class="math notranslate nohighlight">\(N+1\)</span> times to get the gradient – Jacobians are even worse.</p></li>
<li><p>Large <span class="math notranslate nohighlight">\(\Delta\)</span> is numerically stable but inaccurate, too small of <span class="math notranslate nohighlight">\(\Delta\)</span> is numerically unstable but more accurate.</p></li>
<li><p>Choosing the <span class="math notranslate nohighlight">\(\Delta\)</span> is hard, so use packages such as <a class="reference external" href="https://github.com/JuliaDiffEq/DiffEqDiffTools.jl">DiffEqDiffTools.jl</a>.</p></li>
<li><p>If a function is <span class="math notranslate nohighlight">\(R^N \to R\)</span> for a large <span class="math notranslate nohighlight">\(N\)</span>, this requires <span class="math notranslate nohighlight">\(O(N)\)</span> function evaluations.</p></li>
</ul>
</li>
</ul>
<div class="math notranslate nohighlight">
\[
\partial_{x_i}f(x_1,\ldots x_N) \approx \frac{f(x_1,\ldots x_i + \Delta,\ldots x_N) - f(x_1,\ldots x_i,\ldots x_N)}{\Delta}
\]</div>
<ul class="simple">
<li><p>Automatic Differentiation</p>
<ul>
<li><p>The same as analytic/symbolic differentiation, but where the <strong>chain rule</strong> is calculated <strong>numerically</strong> rather than symbolically.</p></li>
<li><p>Just as with analytic derivatives, can establish rules for the derivatives of individual functions (e.g. <span class="math notranslate nohighlight">\(d\left(sin(x)\right)\)</span> to <span class="math notranslate nohighlight">\(cos(x) dx\)</span>) for intrinsic derivatives.</p></li>
</ul>
</li>
</ul>
<p>AD has two basic approaches, which are variations on the order of evaluating the chain rule: reverse and forward mode (although mixed mode is possible).</p>
<ol class="simple">
<li><p>If a function is <span class="math notranslate nohighlight">\(R^N \to R\)</span>, then <strong>reverse-mode</strong> AD can find the gradient in <span class="math notranslate nohighlight">\(O(1)\)</span> sweep (where a “sweep” is <span class="math notranslate nohighlight">\(O(1)\)</span> function evaluations).</p></li>
<li><p>If a function is <span class="math notranslate nohighlight">\(R \to R^N\)</span>, then <strong>forward-mode</strong> AD can find the jacobian in <span class="math notranslate nohighlight">\(O(1)\)</span> sweeps.</p></li>
</ol>
<p>We will explore two types of automatic differentiation in Julia (and discuss a few packages which implement them).  For both, remember the <a class="reference external" href="https://en.wikipedia.org/wiki/Chain_rule">chain rule</a></p>
<div class="math notranslate nohighlight">
\[
\frac{dy}{dx} = \frac{dy}{dw} \cdot \frac{dw}{dx}
\]</div>
<p>Forward-mode starts the calculation from the left with <span class="math notranslate nohighlight">\(\frac{dy}{dw}\)</span> first, which then calculates the product with <span class="math notranslate nohighlight">\(\frac{dw}{dx}\)</span>.  On the other hand, reverse mode starts on the right hand side with <span class="math notranslate nohighlight">\(\frac{dw}{dx}\)</span> and works backwards.</p>
<p>Take an example a function with fundamental operations and known analytical derivatives</p>
<div class="math notranslate nohighlight">
\[
f(x_1, x_2) = x_1 x_2 + \sin(x_1)
\]</div>
<p>And rewrite this as a function which contains a sequence of simple operations and temporaries.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span><span class="w"> </span><span class="n">x_2</span><span class="p">)</span>
<span class="w">    </span><span class="n">w_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x_1</span>
<span class="w">    </span><span class="n">w_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x_2</span>
<span class="w">    </span><span class="n">w_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">w_1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">w_2</span>
<span class="w">    </span><span class="n">w_4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">w_1</span><span class="p">)</span>
<span class="w">    </span><span class="n">w_5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">w_3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">w_4</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">w_5</span>
<span class="k">end</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>f (generic function with 1 method)
</pre></div>
</div>
</div>
</div>
<p>Here we can identify all of the underlying functions (<code class="docutils literal notranslate"><span class="pre">*,</span> <span class="pre">sin,</span> <span class="pre">+</span></code>), and see if each has an
intrinsic derivative.  While these are obvious, with Julia we could come up with all sorts of differentiation rules for arbitrarily
complicated combinations and compositions of intrinsic operations.  In fact, there is even <a class="reference external" href="https://github.com/JuliaDiff/ChainRules.jl">a package</a> for registering more.</p>
<div class="section" id="forward-mode-automatic-differentiation">
<h3><span class="section-number">9.2.1. </span>Forward-Mode Automatic Differentiation<a class="headerlink" href="#forward-mode-automatic-differentiation" title="Permalink to this headline">¶</a></h3>
<p>In forward-mode AD, you first fix the variable you are interested in (called “seeding”), and then evaluate the chain rule in left-to-right order.</p>
<p>For example, with our <span class="math notranslate nohighlight">\(f(x_1, x_2)\)</span> example above, if we wanted to calculate the derivative with respect to <span class="math notranslate nohighlight">\(x_1\)</span> then
we can seed the setup accordingly.  <span class="math notranslate nohighlight">\(\frac{\partial  w_1}{\partial  x_1} = 1\)</span> since we are taking the derivative of it, while <span class="math notranslate nohighlight">\(\frac{\partial  w_2}{\partial  x_1} = 0\)</span>.</p>
<p>Following through with these, redo all of the calculations for the derivative in parallel with the function itself.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{l|l}
f(x_1, x_2) &amp;
\frac{\partial f(x_1,x_2)}{\partial x_1}
\\
\hline
w_1 = x_1 &amp;
\frac{\partial  w_1}{\partial  x_1} = 1 \text{ (seed)}\\
w_2 = x_2 &amp;
\frac{\partial   w_2}{\partial  x_1} = 0 \text{ (seed)}
\\
w_3 = w_1 \cdot w_2 &amp;
\frac{\partial  w_3}{\partial x_1} = w_2 \cdot \frac{\partial   w_1}{\partial  x_1} + w_1 \cdot \frac{\partial   w_2}{\partial  x_1}
\\
w_4 = \sin w_1 &amp;
\frac{\partial   w_4}{\partial x_1} = \cos w_1 \cdot \frac{\partial  w_1}{\partial x_1}
\\
w_5 = w_3 + w_4 &amp;
\frac{\partial  w_5}{\partial x_1} = \frac{\partial  w_3}{\partial x_1} + \frac{\partial  w_4}{\partial x_1}
\end{array}
\end{split}\]</div>
<p>Since these two could be done at the same time, we say there is “one pass” required for this calculation.</p>
<p>Generalizing a little, if the function was vector-valued, then that single pass would get the entire row of the Jacobian in that single pass.  Hence for a <span class="math notranslate nohighlight">\(R^N \to R^M\)</span> function, requires <span class="math notranslate nohighlight">\(N\)</span> passes to get a dense Jacobian using forward-mode AD.</p>
<p>How can you implement forward-mode AD?  It turns out to be fairly easy with a generic programming language to make a simple example (while the devil is in the details for
a high-performance implementation).</p>
</div>
<div class="section" id="forward-mode-with-dual-numbers">
<h3><span class="section-number">9.2.2. </span>Forward-Mode with Dual Numbers<a class="headerlink" href="#forward-mode-with-dual-numbers" title="Permalink to this headline">¶</a></h3>
<p>One way to implement forward-mode AD is to use <a class="reference external" href="https://en.wikipedia.org/wiki/Dual_number">dual numbers</a>.</p>
<p>Instead of working with just a real number, e.g. <span class="math notranslate nohighlight">\(x\)</span>, we will augment each with an infinitesimal <span class="math notranslate nohighlight">\(\epsilon\)</span> and use <span class="math notranslate nohighlight">\(x + \epsilon\)</span>.</p>
<p>From Taylor’s theorem,</p>
<div class="math notranslate nohighlight">
\[
f(x + \epsilon) = f(x) + f'(x)\epsilon + O(\epsilon^2)
\]</div>
<p>where we will define the infinitesimal such that <span class="math notranslate nohighlight">\(\epsilon^2 = 0\)</span>.</p>
<p>With this definition, we can write a general rule for differentiation of <span class="math notranslate nohighlight">\(g(x,y)\)</span> as the chain rule for the total derivative</p>
<div class="math notranslate nohighlight">
\[
g(x + \epsilon, y + \epsilon) = g(x, y) + (\partial_x g(x,y) + \partial_y g(x,y))\epsilon
\]</div>
<p>But, note that if we keep track of the constant in front of the <span class="math notranslate nohighlight">\(\epsilon\)</span> terms (e.g. a <span class="math notranslate nohighlight">\(x'\)</span> and <span class="math notranslate nohighlight">\(y'\)</span>)</p>
<div class="math notranslate nohighlight">
\[
g(x + x'\epsilon, y + y'\epsilon) = g(x, y) + (\partial_x g(x,y)x' + \partial_y g(x,y)y')\epsilon
\]</div>
<p>This is simply the chain rule.  A few more examples</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
        (x + x'\epsilon) + (y + y'\epsilon) &amp;= (x + y) + (x' + y')\epsilon\\
(x + x'\epsilon)\times(y + y'\epsilon) &amp;= (xy) + (x'y + y'x)\epsilon\\
\exp(x + x'\epsilon) &amp;= \exp(x) + (x'\exp(x))\epsilon\\
        \end{aligned}
\end{split}\]</div>
<p>Using the generic programming in Julia, it is easy to define a new dual number type which can encapsulate the pair <span class="math notranslate nohighlight">\((x, x')\)</span> and provide a definitions for
all of the basic operations.  Each definition then has the chain-rule built into it.</p>
<p>With this approach, the “seed” process is simple the creation of the <span class="math notranslate nohighlight">\(\epsilon\)</span> for the underlying variable.</p>
<p>So if we have the function <span class="math notranslate nohighlight">\(f(x_1, x_2)\)</span> and we wanted to find the derivative <span class="math notranslate nohighlight">\(\partial_{x_1} f(3.8, 6.9)\)</span> then then we would seed them with the dual numbers <span class="math notranslate nohighlight">\(x_1 \to (3.8, 1)\)</span> and <span class="math notranslate nohighlight">\(x_2 \to (6.9, 0)\)</span>.</p>
<p>If you then follow all of the same scalar operations above with a seeded dual number, it will calculate both the function value and the derivative in a single “sweep” and without modifying any of your (generic) code.</p>
</div>
<div class="section" id="forwarddiff-jl">
<h3><span class="section-number">9.2.3. </span>ForwardDiff.jl<a class="headerlink" href="#forwarddiff-jl" title="Permalink to this headline">¶</a></h3>
<p>Dual-numbers are at the heart of one of the AD packages we have already seen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">ForwardDiff</span>
<span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sinh</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="w"> </span><span class="c"># multivariate.</span>
<span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">1.4</span><span class="w"> </span><span class="mf">2.2</span><span class="p">]</span>
<span class="nd">@show</span><span class="w"> </span><span class="n">ForwardDiff</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="c"># use AD, seeds from x</span>

<span class="c">#Or, can use complicated functions of many variables</span>
<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">prod</span><span class="p">(</span><span class="n">tan</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">sqrt</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">ForwardDiff</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c"># g() is now the gradient</span>
<span class="n">g</span><span class="p">(</span><span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span><span class="w"> </span><span class="c"># gradient at a random point</span>
<span class="c"># ForwardDiff.hessian(f,x&#39;) # or the hessian</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ForwardDiff.gradient(h, x) = [26.35476496103098 16.663053156992287]
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>5-element Vector{Float64}:
 0.938635018559641
 0.5717146899819197
 1.017607989060555
 1.1877184096005307
 0.7911335320841995
</pre></div>
</div>
</div>
</div>
<p>We can even auto-differentiate complicated functions with embedded iterations.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span><span class="n">squareroot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="c">#pretending we don&#39;t know sqrt()</span>
<span class="w">    </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="c"># Initial starting point for Newton’s method</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">1e-13</span>
<span class="w">        </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="n">z</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">z</span>
<span class="k">end</span>
<span class="n">squareroot</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.4142135623730951
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">ForwardDiff</span>
<span class="n">dsqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ForwardDiff</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">squareroot</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="n">dsqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.35355339059327373
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="zygote-jl">
<h3><span class="section-number">9.2.4. </span>Zygote.jl<a class="headerlink" href="#zygote-jl" title="Permalink to this headline">¶</a></h3>
<p>Unlike forward-mode auto-differentiation, reverse-mode is very difficult to implement efficiently, and there are many variations on the best approach.</p>
<p>Many reverse-mode packages are connected to machine-learning packages, since the efficient gradients of <span class="math notranslate nohighlight">\(R^N \to R\)</span> loss functions are necessary for the gradient descent optimization algorithms used in machine learning.</p>
<p>One recent package is <a class="reference external" href="https://github.com/FluxML/Zygote.jl">Zygote.jl</a>, which is used in the Flux.jl framework.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">Zygote</span>

<span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y</span>
<span class="n">gradient</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(25.0, 2.0)
</pre></div>
</div>
</div>
</div>
<p>Here we see that Zygote has a gradient function as the interface, which returns a tuple.</p>
<p>You could create this as an operator if you wanted to.,</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">D</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="o">-&gt;</span><span class="w"> </span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="w">  </span><span class="c"># returns first in tuple</span>

<span class="n">D_sin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">D</span><span class="p">(</span><span class="n">sin</span><span class="p">)</span>
<span class="n">D_sin</span><span class="p">(</span><span class="mf">4.0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-0.6536436208636119
</pre></div>
</div>
</div>
</div>
<p>For functions of one (Julia) variable, we can find the by simply using the <code class="docutils literal notranslate"><span class="pre">'</span></code> after a function name</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">Statistics</span>
<span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mean</span><span class="p">(</span><span class="n">abs</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="n">p</span><span class="o">&#39;</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">2.0</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3-element Vector{Float64}:
  0.3333333333333333
  0.3333333333333333
 -0.3333333333333333
</pre></div>
</div>
</div>
</div>
<p>Or, using the complicated iterative function we defined for the squareroot,</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">squareroot</span><span class="o">&#39;</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.3535533905932737
</pre></div>
</div>
</div>
</div>
<p>Zygote supports combinations of vectors and scalars as the function parameters.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="o">.^</span><span class="n">n</span><span class="p">))</span><span class="o">^</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">n</span><span class="p">)</span>
<span class="n">gradient</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">4.0</span><span class="p">,</span><span class="w"> </span><span class="mf">6.0</span><span class="p">],</span><span class="w"> </span><span class="mf">2.0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>([0.137360563948689, 0.549442255794756, 0.824163383692134], -1.2725553130925453)
</pre></div>
</div>
</div>
</div>
<p>The gradients can be very high dimensional.  For example, to do a simple nonlinear optimization problem
with 1 million dimensions, solved in a few seconds.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">Optim</span><span class="p">,</span><span class="w"> </span><span class="n">LinearAlgebra</span>
<span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000000</span>
<span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rand</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">λ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.01</span>
<span class="n">obj</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="p">((</span><span class="n">x</span><span class="w"> </span><span class="o">.-</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">λ</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="n">x_iv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rand</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="k">function</span><span class="w"> </span><span class="n">g!</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="n">G</span><span class="w"> </span><span class="o">.=</span><span class="w">  </span><span class="n">obj</span><span class="o">&#39;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">optimize</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="n">g!</span><span class="p">,</span><span class="w"> </span><span class="n">x_iv</span><span class="p">,</span><span class="w"> </span><span class="n">LBFGS</span><span class="p">())</span><span class="w"> </span><span class="c"># or ConjugateGradient()</span>
<span class="n">println</span><span class="p">(</span><span class="s">&quot;minimum = </span><span class="si">$</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">minimum</span><span class="p">)</span><span class="s"> with in &quot;</span><span class="o">*</span>
<span class="s">&quot;</span><span class="si">$</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">iterations</span><span class="p">)</span><span class="s"> iterations&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>minimum = 5.773873075271588 with in 2 iterations
</pre></div>
</div>
</div>
</div>
<p>Caution: while Zygote is the most exciting reverse-mode AD implementation in Julia, it has many rough edges.</p>
<ul class="simple">
<li><p>If you write a function, take its gradient, and then modify the function, you need to call <code class="docutils literal notranslate"><span class="pre">Zygote.refresh()</span></code> or else the gradient will be out of sync.  This may not apply for Julia 1.3+.</p></li>
<li><p>It provides no features for getting Jacobians, so you would have to ask for each row of the Jacobian separately.  That said, you
probably want to use  <code class="docutils literal notranslate"><span class="pre">ForwardDiff.jl</span></code> for Jacobians if the dimension of the output is similar to the dimension of the input.</p></li>
<li><p>You cannot, in the current release, use mutating functions (e.g. modify a value in an array/etc.) although that feature is in progress.</p></li>
<li><p>Compiling can be very slow for complicated functions.</p></li>
</ul>
</div>
</div>
<div class="section" id="optimization">
<h2><a class="toc-backref" href="#id4"><span class="section-number">9.3. </span>Optimization</a><a class="headerlink" href="#optimization" title="Permalink to this headline">¶</a></h2>
<p>There are a large number of packages intended to be used for optimization in Julia.</p>
<p>Part of the reason for the diversity of options is that Julia makes it possible to efficiently implement a large number of variations on optimization routines.</p>
<p>The other reason is that different types of optimization problems require different algorithms.</p>
<div class="section" id="optim-jl">
<h3><span class="section-number">9.3.1. </span>Optim.jl<a class="headerlink" href="#optim-jl" title="Permalink to this headline">¶</a></h3>
<p>A good pure-Julia solution for the (unconstrained or box-bounded) optimization of
univariate and multivariate function is the <a class="reference external" href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a> package.</p>
<p>By default, the algorithms in <code class="docutils literal notranslate"><span class="pre">Optim.jl</span></code> target minimization rather than
maximization, so if a function is called <code class="docutils literal notranslate"><span class="pre">optimize</span></code> it will mean minimization.</p>
<div class="section" id="univariate-functions-on-bounded-intervals">
<h4><span class="section-number">9.3.1.1. </span>Univariate Functions on Bounded Intervals<a class="headerlink" href="#univariate-functions-on-bounded-intervals" title="Permalink to this headline">¶</a></h4>
<p><a class="reference external" href="http://julianlsolvers.github.io/Optim.jl/stable/user/minimization/#minimizing-a-univariate-function-on-a-bounded-interval">Univariate optimization</a>
defaults to a robust hybrid optimization routine called <a class="reference external" href="https://en.wikipedia.org/wiki/Brent%27s_method">Brent’s method</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">Optim</span>
<span class="k">using</span><span class="w"> </span><span class="n">Optim</span><span class="o">:</span><span class="w"> </span><span class="n">converged</span><span class="p">,</span><span class="w"> </span><span class="n">maximum</span><span class="p">,</span><span class="w"> </span><span class="n">maximizer</span><span class="p">,</span><span class="w"> </span><span class="n">minimizer</span><span class="p">,</span><span class="w"> </span><span class="n">iterations</span><span class="w"> </span><span class="c">#some extra functions</span>

<span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">optimize</span><span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Results of Optimization Algorithm
 * Algorithm: Brent&#39;s Method
 * Search Interval: [-2.000000, 1.000000]
 * Minimizer: 0.000000e+00
 * Minimum: 0.000000e+00
 * Iterations: 5
 * Convergence: max(|x - x_upper|, |x - x_lower|) &lt;= 2*(1.5e-08*|x|+2.2e-16): true
 * Objective Function Calls: 6
</pre></div>
</div>
</div>
</div>
<p>Always check if the results converged, and throw errors otherwise</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">converged</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">error</span><span class="p">(</span><span class="s">&quot;Failed to converge in </span><span class="si">$</span><span class="p">(</span><span class="n">iterations</span><span class="p">(</span><span class="n">result</span><span class="p">))</span><span class="s"> iterations&quot;</span><span class="p">)</span>
<span class="n">xmin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="o">.</span><span class="n">minimizer</span>
<span class="n">result</span><span class="o">.</span><span class="n">minimum</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.0
</pre></div>
</div>
</div>
</div>
<p>The first line is a logical OR between <code class="docutils literal notranslate"><span class="pre">converged(result)</span></code> and <code class="docutils literal notranslate"><span class="pre">error(&quot;...&quot;)</span></code>.</p>
<p>If the convergence check passes, the logical sentence is true, and it will proceed to the next line; if not, it will throw the error.</p>
<p>Or to maximize</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span>
<span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">maximize</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">converged</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">error</span><span class="p">(</span><span class="s">&quot;Failed to converge in </span><span class="si">$</span><span class="p">(</span><span class="n">iterations</span><span class="p">(</span><span class="n">result</span><span class="p">))</span><span class="s"> iterations&quot;</span><span class="p">)</span>
<span class="n">xmin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">maximizer</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="n">fmax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">maximum</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-0.0
</pre></div>
</div>
</div>
</div>
<p><strong>Note:</strong> Notice that we call <code class="docutils literal notranslate"><span class="pre">optimize</span></code> results using <code class="docutils literal notranslate"><span class="pre">result.minimizer</span></code>, and <code class="docutils literal notranslate"><span class="pre">maximize</span></code> results using <code class="docutils literal notranslate"><span class="pre">maximizer(result)</span></code>.</p>
</div>
<div class="section" id="unconstrained-multivariate-optimization">
<h4><span class="section-number">9.3.1.2. </span>Unconstrained Multivariate Optimization<a class="headerlink" href="#unconstrained-multivariate-optimization" title="Permalink to this headline">¶</a></h4>
<p>There are a variety of <a class="reference external" href="http://julianlsolvers.github.io/Optim.jl/stable/user/minimization/#_top">algorithms and options</a> for multivariate optimization.</p>
<p>From the documentation, the simplest version is</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">100.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span>
<span class="n">x_iv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">]</span>
<span class="n">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">optimize</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">x_iv</span><span class="p">)</span><span class="w"> </span><span class="c"># i.e. optimize(f, x_iv, NelderMead())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> * Status: success

 * Candidate solution
    Final objective value:     3.525527e-09

 * Found with
    Algorithm:     Nelder-Mead

 * Convergence measures
    √(Σ(yᵢ-ȳ)²)/n ≤ 1.0e-08

 * Work counters
    Seconds run:   0  (vs limit Inf)
    Iterations:    60
    f(x) calls:    117
</pre></div>
</div>
</div>
</div>
<p>The default algorithm in <code class="docutils literal notranslate"><span class="pre">NelderMead</span></code>, which is derivative-free and hence requires many function evaluations.</p>
<p>To change the algorithm type to <a class="reference external" href="http://julianlsolvers.github.io/Optim.jl/stable/algo/lbfgs/">L-BFGS</a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">optimize</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">x_iv</span><span class="p">,</span><span class="w"> </span><span class="n">LBFGS</span><span class="p">())</span>
<span class="n">println</span><span class="p">(</span><span class="s">&quot;minimum = </span><span class="si">$</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">minimum</span><span class="p">)</span><span class="s"> with argmin = </span><span class="si">$</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">minimizer</span><span class="p">)</span><span class="s"> in &quot;</span><span class="o">*</span>
<span class="s">&quot;</span><span class="si">$</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">iterations</span><span class="p">)</span><span class="s"> iterations&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>minimum = 5.3784046148998115e-17 with argmin = [0.9999999926662393, 0.9999999853324786] in 24 iterations
</pre></div>
</div>
</div>
</div>
<p>Note that this has fewer iterations.</p>
<p>As no derivative was given, it used <a class="reference external" href="https://en.wikipedia.org/wiki/Finite_difference">finite differences</a> to approximate the gradient of <code class="docutils literal notranslate"><span class="pre">f(x)</span></code>.</p>
<p>However, since most of the algorithms require derivatives, you will often want to use auto differentiation or pass analytical gradients if possible.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">100.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span>
<span class="n">x_iv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">]</span>
<span class="n">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">optimize</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">x_iv</span><span class="p">,</span><span class="w"> </span><span class="n">LBFGS</span><span class="p">(),</span><span class="w"> </span><span class="n">autodiff</span><span class="o">=</span><span class="ss">:forward</span><span class="p">)</span><span class="w"> </span><span class="c"># i.e. use ForwardDiff.jl</span>
<span class="n">println</span><span class="p">(</span><span class="s">&quot;minimum = </span><span class="si">$</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">minimum</span><span class="p">)</span><span class="s"> with argmin = </span><span class="si">$</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">minimizer</span><span class="p">)</span><span class="s"> in &quot;</span><span class="o">*</span>
<span class="s">&quot;</span><span class="si">$</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">iterations</span><span class="p">)</span><span class="s"> iterations&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>minimum = 5.191703158437428e-27 with argmin = [0.999999999999928, 0.9999999999998559] in 24 iterations
</pre></div>
</div>
</div>
</div>
<p>Note that we did not need to use <code class="docutils literal notranslate"><span class="pre">ForwardDiff.jl</span></code> directly, as long as our <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> function was written to be generic (see the <a class="reference internal" href="generic_programming.html"><span class="doc">generic programming lecture</span></a> ).</p>
<p>Alternatively, with an analytical gradient</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">100.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span>
<span class="n">x_iv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">]</span>
<span class="k">function</span><span class="w"> </span><span class="n">g!</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="n">G</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">400.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="w">    </span><span class="n">G</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">200.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">optimize</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">g!</span><span class="p">,</span><span class="w"> </span><span class="n">x_iv</span><span class="p">,</span><span class="w"> </span><span class="n">LBFGS</span><span class="p">())</span><span class="w"> </span><span class="c"># or ConjugateGradient()</span>
<span class="n">println</span><span class="p">(</span><span class="s">&quot;minimum = </span><span class="si">$</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">minimum</span><span class="p">)</span><span class="s"> with argmin = </span><span class="si">$</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">minimizer</span><span class="p">)</span><span class="s"> in &quot;</span><span class="o">*</span>
<span class="s">&quot;</span><span class="si">$</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">iterations</span><span class="p">)</span><span class="s"> iterations&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>minimum = 5.191703158437428e-27 with argmin = [0.999999999999928, 0.9999999999998559] in 24 iterations
</pre></div>
</div>
</div>
</div>
<p>For derivative-free methods, you can change the algorithm – and have no need to provide a gradient</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">100.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span>
<span class="n">x_iv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">]</span>
<span class="n">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">optimize</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">x_iv</span><span class="p">,</span><span class="w"> </span><span class="n">SimulatedAnnealing</span><span class="p">())</span><span class="w"> </span><span class="c"># or ParticleSwarm() or NelderMead()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> * Status: failure (reached maximum number of iterations)

 * Candidate solution
    Final objective value:     1.065839e-01

 * Found with
    Algorithm:     Simulated Annealing

 * Convergence measures
    |x - x&#39;|               = NaN ≰ 0.0e+00
    |x - x&#39;|/|x&#39;|          = NaN ≰ 0.0e+00
    |f(x) - f(x&#39;)|         = NaN ≰ 0.0e+00
    |f(x) - f(x&#39;)|/|f(x&#39;)| = NaN ≰ 0.0e+00
    |g(x)|                 = NaN ≰ 1.0e-08

 * Work counters
    Seconds run:   0  (vs limit Inf)
    Iterations:    1000
    f(x) calls:    1001
</pre></div>
</div>
</div>
</div>
<p>However, you will note that this did not converge, as stochastic methods typically require many more iterations as a tradeoff for their global-convergence properties.</p>
<p>See the <a class="reference external" href="http://julianlsolvers.github.io/Optim.jl/stable/examples/generated/maxlikenlm/">maximum likelihood</a>
example and the accompanying <a class="reference external" href="https://nbviewer.jupyter.org/github/JuliaNLSolvers/Optim.jl/blob/gh-pages/v0.15.3/examples/generated/maxlikenlm.ipynb">Jupyter notebook</a>.</p>
</div>
</div>
<div class="section" id="jump-jl">
<h3><span class="section-number">9.3.2. </span>JuMP.jl<a class="headerlink" href="#jump-jl" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="https://github.com/JuliaOpt/JuMP.jl">JuMP.jl</a> package is an ambitious implementation of a modelling language for optimization problems in Julia.</p>
<p>In that sense, it is more like an AMPL (or Pyomo) built on top of the Julia
language with macros, and able to use a variety of different commerical and open source solvers.</p>
<p>If you have a linear, quadratic, conic, mixed-integer linear, etc. problem then this will likely be the ideal “meta-package” for calling various solvers.</p>
<p>For nonlinear problems, the modelling language may make things difficult for complicated functions (as it is not designed to be used as a general-purpose nonlinear optimizer).</p>
<p>See the <a class="reference external" href="http://www.juliaopt.org/JuMP.jl/0.18/quickstart.html">quick start guide</a> for more details on all of the options.</p>
<p>The following is an example of calling a linear objective with a nonlinear constraint (provided by an external function).</p>
<p>Here <code class="docutils literal notranslate"><span class="pre">Ipopt</span></code> stands for <code class="docutils literal notranslate"><span class="pre">Interior</span> <span class="pre">Point</span> <span class="pre">OPTimizer</span></code>, a <a class="reference external" href="https://github.com/JuliaOpt/Ipopt.jl">nonlinear solver</a> in Julia</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">JuMP</span><span class="p">,</span><span class="w"> </span><span class="n">Ipopt</span>
<span class="c"># solve</span>
<span class="c"># max( x[1] + x[2] )</span>
<span class="c"># st sqrt(x[1]^2 + x[2]^2) &lt;= 1</span>

<span class="k">function</span><span class="w"> </span><span class="n">squareroot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="c"># pretending we don&#39;t know sqrt()</span>
<span class="w">    </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="c"># Initial starting point for Newton’s method</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">1e-13</span>
<span class="w">        </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="n">z</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">z</span>
<span class="k">end</span>
<span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Model</span><span class="p">(</span><span class="n">Ipopt</span><span class="o">.</span><span class="n">Optimizer</span><span class="p">)</span>
<span class="c"># need to register user defined functions for AD</span>
<span class="n">JuMP</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="ss">:squareroot</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">squareroot</span><span class="p">,</span><span class="w"> </span><span class="n">autodiff</span><span class="o">=</span><span class="nb">true</span><span class="p">)</span>

<span class="nd">@variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">start</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span><span class="w"> </span><span class="c"># start is the initial condition</span>
<span class="nd">@objective</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">Max</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="nd">@NLconstraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">squareroot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="nd">@show</span><span class="w"> </span><span class="n">JuMP</span><span class="o">.</span><span class="n">optimize!</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>******************************************************************************
This program contains Ipopt, a library for large-scale nonlinear optimization.
 Ipopt is released as open source code under the Eclipse Public License (EPL).
         For more information visit https://github.com/coin-or/Ipopt
******************************************************************************

This is Ipopt version 3.14.4, running with linear solver MUMPS 5.4.1.

Number of nonzeros in equality constraint Jacobian...:        0
Number of nonzeros in inequality constraint Jacobian.:        2
Number of nonzeros in Lagrangian Hessian.............:        3

Total number of variables............................:        2
                     variables with only lower bounds:        0
                variables with lower and upper bounds:        0
                     variables with only upper bounds:        0
Total number of equality constraints.................:        0
Total number of inequality constraints...............:        1
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:        1

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  1.0000000e+00 0.00e+00 2.07e-01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  1.4100714e+00 0.00e+00 5.48e-02  -1.7 3.94e-01    -  1.00e+00 7.36e-01f  1
   2  1.4113851e+00 0.00e+00 2.83e-08  -2.5 9.29e-04    -  1.00e+00 1.00e+00f  1
   3  1.4140632e+00 0.00e+00 1.50e-09  -3.8 1.89e-03    -  1.00e+00 1.00e+00f  1
   4  1.4142117e+00 0.00e+00 1.84e-11  -5.7 1.05e-04    -  1.00e+00 1.00e+00f  1
   5  1.4142136e+00 0.00e+00 8.23e-09  -8.6 1.30e-06    -  1.00e+00 1.00e+00f  1

Number of Iterations....: 5

                                   (scaled)                 (unscaled)
Objective...............:  -1.4142135740093271e+00    1.4142135740093271e+00
Dual infeasibility......:   8.2280586788385790e-09    8.2280586788385790e-09
Constraint violation....:   0.0000000000000000e+00    0.0000000000000000e+00
Variable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00
Complementarity.........:   2.5059035815063646e-09    2.5059035815063646e-09
Overall NLP error.......:   8.2280586788385790e-09    8.2280586788385790e-09


Number of objective function evaluations             = 6
Number of objective gradient evaluations             = 6
Number of equality constraint evaluations            = 0
Number of inequality constraint evaluations          = 6
Number of equality constraint Jacobian evaluations   = 0
Number of inequality constraint Jacobian evaluations = 6
Number of Lagrangian Hessian evaluations             = 5
Total seconds in IPOPT                               = 2.991

EXIT: Optimal Solution Found.
JuMP.optimize!(m) = nothing
</pre></div>
</div>
</div>
</div>
<p>And this is an example of a quadratic objective</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="c"># solve</span>
<span class="c"># min (1-x)^2 + 100(y-x^2)^2)</span>
<span class="c"># st x + y &gt;= 10</span>

<span class="k">using</span><span class="w"> </span><span class="n">JuMP</span><span class="p">,</span><span class="n">Ipopt</span>
<span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Model</span><span class="p">(</span><span class="n">Ipopt</span><span class="o">.</span><span class="n">Optimizer</span><span class="p">)</span><span class="w"> </span><span class="c"># settings for the solver</span>
<span class="nd">@variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="nd">@variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>

<span class="nd">@NLobjective</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">Min</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">100</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>

<span class="n">JuMP</span><span class="o">.</span><span class="n">optimize!</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">println</span><span class="p">(</span><span class="s">&quot;x = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="s">&quot; y = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

<span class="c"># adding a (linear) constraint</span>
<span class="nd">@constraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span>
<span class="n">JuMP</span><span class="o">.</span><span class="n">optimize!</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">println</span><span class="p">(</span><span class="s">&quot;x = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="s">&quot; y = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>This is Ipopt version 3.14.4, running with linear solver MUMPS 5.4.1.

Number of nonzeros in equality constraint Jacobian...:        0
Number of nonzeros in inequality constraint Jacobian.:        0
Number of nonzeros in Lagrangian Hessian.............:        3

Total number of variables............................:        2
                     variables with only lower bounds:        0
                variables with lower and upper bounds:        0
                     variables with only upper bounds:        0
Total number of equality constraints.................:        0
Total number of inequality constraints...............:        0
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:        0

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  1.0000000e+00 0.00e+00 2.00e+00  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  9.5312500e-01 0.00e+00 1.25e+01  -1.0 1.00e+00    -  1.00e+00 2.50e-01f  3
   2  4.8320569e-01 0.00e+00 1.01e+00  -1.0 9.03e-02    -  1.00e+00 1.00e+00f  1
   3  4.5708829e-01 0.00e+00 9.53e+00  -1.0 4.29e-01    -  1.00e+00 5.00e-01f  2
   4  1.8894205e-01 0.00e+00 4.15e-01  -1.0 9.51e-02    -  1.00e+00 1.00e+00f  1
   5  1.3918726e-01 0.00e+00 6.51e+00  -1.7 3.49e-01    -  1.00e+00 5.00e-01f  2
   6  5.4940990e-02 0.00e+00 4.51e-01  -1.7 9.29e-02    -  1.00e+00 1.00e+00f  1
   7  2.9144630e-02 0.00e+00 2.27e+00  -1.7 2.49e-01    -  1.00e+00 5.00e-01f  2
   8  9.8586451e-03 0.00e+00 1.15e+00  -1.7 1.10e-01    -  1.00e+00 1.00e+00f  1
   9  2.3237475e-03 0.00e+00 1.00e+00  -1.7 1.00e-01    -  1.00e+00 1.00e+00f  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  2.3797236e-04 0.00e+00 2.19e-01  -1.7 5.09e-02    -  1.00e+00 1.00e+00f  1
  11  4.9267371e-06 0.00e+00 5.95e-02  -1.7 2.53e-02    -  1.00e+00 1.00e+00f  1
  12  2.8189505e-09 0.00e+00 8.31e-04  -2.5 3.20e-03    -  1.00e+00 1.00e+00f  1
  13  1.0095040e-15 0.00e+00 8.68e-07  -5.7 9.78e-05    -  1.00e+00 1.00e+00f  1
  14  1.3288608e-28 0.00e+00 2.02e-13  -8.6 4.65e-08    -  1.00e+00 1.00e+00f  1

Number of Iterations....: 14

                                   (scaled)                 (unscaled)
Objective...............:   1.3288608467480825e-28    1.3288608467480825e-28
Dual infeasibility......:   2.0183854587685121e-13    2.0183854587685121e-13
Constraint violation....:   0.0000000000000000e+00    0.0000000000000000e+00
Variable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00
Complementarity.........:   0.0000000000000000e+00    0.0000000000000000e+00
Overall NLP error.......:   2.0183854587685121e-13    2.0183854587685121e-13


Number of objective function evaluations             = 36
Number of objective gradient evaluations             = 15
Number of equality constraint evaluations            = 0
Number of inequality constraint evaluations          = 0
Number of equality constraint Jacobian evaluations   = 0
Number of inequality constraint Jacobian evaluations = 0
Number of Lagrangian Hessian evaluations             = 14
Total seconds in IPOPT                               = 0.033

EXIT: Optimal Solution Found.
x = 0.9999999999999899 y = 0.9999999999999792
This is Ipopt version 3.14.4, running with linear solver MUMPS 5.4.1.

Number of nonzeros in equality constraint Jacobian...:        2
Number of nonzeros in inequality constraint Jacobian.:        0
Number of nonzeros in Lagrangian Hessian.............:        3

Total number of variables............................:        2
                     variables with only lower bounds:        0
                variables with lower and upper bounds:        0
                     variables with only upper bounds:        0
Total number of equality constraints.................:        1
Total number of inequality constraints...............:        0
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:        0

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  1.0000000e+00 1.00e+01 1.00e+00  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  9.6315968e+05 1.78e-15 3.89e+05  -1.0 9.91e+00    -  1.00e+00 1.00e+00h  1
   2  1.6901461e+05 0.00e+00 1.16e+05  -1.0 3.24e+00    -  1.00e+00 1.00e+00f  1
   3  2.5433173e+04 0.00e+00 3.18e+04  -1.0 2.05e+00    -  1.00e+00 1.00e+00f  1
   4  2.6527756e+03 0.00e+00 7.79e+03  -1.0 1.19e+00    -  1.00e+00 1.00e+00f  1
   5  1.1380324e+02 0.00e+00 1.35e+03  -1.0 5.62e-01    -  1.00e+00 1.00e+00f  1
   6  3.3745506e+00 0.00e+00 8.45e+01  -1.0 1.50e-01    -  1.00e+00 1.00e+00f  1
   7  2.8946196e+00 0.00e+00 4.22e-01  -1.0 1.07e-02    -  1.00e+00 1.00e+00f  1
   8  2.8946076e+00 0.00e+00 1.07e-05  -1.7 5.42e-05    -  1.00e+00 1.00e+00f  1
   9  2.8946076e+00 0.00e+00 5.91e-13  -8.6 1.38e-09    -  1.00e+00 1.00e+00f  1

Number of Iterations....: 9

                                   (scaled)                 (unscaled)
Objective...............:   2.8946075504894599e+00    2.8946075504894599e+00
Dual infeasibility......:   5.9130478291535837e-13    5.9130478291535837e-13
Constraint violation....:   0.0000000000000000e+00    0.0000000000000000e+00
Variable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00
Complementarity.........:   0.0000000000000000e+00    0.0000000000000000e+00
Overall NLP error.......:   5.9130478291535837e-13    5.9130478291535837e-13


Number of objective function evaluations             = 10
Number of objective gradient evaluations             = 10
Number of equality constraint evaluations            = 10
Number of inequality constraint evaluations          = 0
Number of equality constraint Jacobian evaluations   = 1
Number of inequality constraint Jacobian evaluations = 0
Number of Lagrangian Hessian evaluations             = 9
Total seconds in IPOPT                               = 0.004

EXIT: Optimal Solution Found.
x = 
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.701147124098218 y = 7.2988528759017814
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="blackboxoptim-jl">
<h3><span class="section-number">9.3.3. </span>BlackBoxOptim.jl<a class="headerlink" href="#blackboxoptim-jl" title="Permalink to this headline">¶</a></h3>
<p>Another package for doing global optimization without derivatives is <a class="reference external" href="https://github.com/robertfeldt/BlackBoxOptim.jl">BlackBoxOptim.jl</a>.</p>
<p>To see an example from the documentation</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">BlackBoxOptim</span>

<span class="k">function</span><span class="w"> </span><span class="n">rosenbrock2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">100.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span>
<span class="k">end</span>

<span class="n">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bboptimize</span><span class="p">(</span><span class="n">rosenbrock2d</span><span class="p">;</span><span class="w"> </span><span class="n">SearchRange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">-</span><span class="mf">5.0</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0</span><span class="p">),</span><span class="w"> </span><span class="n">NumDimensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Starting optimization with optimizer DiffEvoOpt{FitPopulation{Float64}, RadiusLimitedSelector, BlackBoxOptim.AdaptiveDiffEvoRandBin{3}, RandomBound{ContinuousRectSearchSpace}}
0.00 secs, 0 evals, 0 steps

Optimization stopped after 10001 steps and 0.05 seconds
Termination reason: Max number of steps (10000) reached
Steps per second = 196818.94
Function evals per second = 198865.66
Improvements/step = 0.20710
Total function evaluations = 10105


Best candidate found: 
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1.0, 1.0]

Fitness: 0.000000000
</pre></div>
</div>
</div>
</div>
<p>An example for <a class="reference external" href="https://github.com/robertfeldt/BlackBoxOptim.jl/blob/master/examples/rosenbrock_parallel.jl">parallel execution</a> of the objective is provided.</p>
</div>
</div>
<div class="section" id="systems-of-equations-and-least-squares">
<h2><a class="toc-backref" href="#id5"><span class="section-number">9.4. </span>Systems of Equations and Least Squares</a><a class="headerlink" href="#systems-of-equations-and-least-squares" title="Permalink to this headline">¶</a></h2>
<div class="section" id="roots-jl">
<h3><span class="section-number">9.4.1. </span>Roots.jl<a class="headerlink" href="#roots-jl" title="Permalink to this headline">¶</a></h3>
<p>A root of a real function <span class="math notranslate nohighlight">\(f\)</span> on <span class="math notranslate nohighlight">\([a,b]\)</span> is an <span class="math notranslate nohighlight">\(x \in [a, b]\)</span> such that <span class="math notranslate nohighlight">\(f(x)=0\)</span>.</p>
<p>For example, if we plot the function</p>
<div class="math notranslate nohighlight" id="equation-root-f">
<span class="eqno">(9.1)<a class="headerlink" href="#equation-root-f" title="Permalink to this equation">¶</a></span>\[f(x) = \sin(4 (x - 1/4)) + x + x^{20} - 1\]</div>
<p>with <span class="math notranslate nohighlight">\(x \in [0,1]\)</span> we get</p>
<div class="figure align-default">
<img alt="../_images/sine-screenshot-2.png" src="../_images/sine-screenshot-2.png" />
</div>
<p>The unique root is approximately 0.408.</p>
<p>The <a class="reference external" href="https://github.com/JuliaLang/Roots.jl">Roots.jl</a> package offers <code class="docutils literal notranslate"><span class="pre">fzero()</span></code> to find roots</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">Roots</span>
<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="o">^</span><span class="mi">20</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>
<span class="n">fzero</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.40829350427936706
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="nlsolve-jl">
<h3><span class="section-number">9.4.2. </span>NLsolve.jl<a class="headerlink" href="#nlsolve-jl" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="https://github.com/JuliaNLSolvers/NLsolve.jl/">NLsolve.jl</a> package provides functions to solve for multivariate systems of equations and fixed points.</p>
<p>From the documentation, to solve for a system of equations without providing a Jacobian</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">NLsolve</span>

<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span><span class="o">+</span><span class="mi">18</span>
<span class="w">        </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span><span class="w"> </span><span class="c"># returns an array</span>

<span class="n">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nlsolve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="mf">0.1</span><span class="p">;</span><span class="w"> </span><span class="mf">1.2</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Results of Nonlinear Solver Algorithm
 * Algorithm: Trust-region with dogleg and autoscaling
 * Starting Point: [0.1, 1.2]
 * Zero: [-7.775548712324193e-17, 0.9999999999999999]
 * Inf-norm of residuals: 0.000000
 * Iterations: 4
 * Convergence: true
   * |x - x&#39;| &lt; 0.0e+00: false
   * |f(x)| &lt; 1.0e-08: true
 * Function Calls (f): 5
 * Jacobian Calls (df/dx): 5
</pre></div>
</div>
</div>
</div>
<p>In the above case, the algorithm used finite differences to calculate the Jacobian.</p>
<p>Alternatively, if <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> is written generically, you can use auto-differentiation with a single setting.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nlsolve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="mf">0.1</span><span class="p">;</span><span class="w"> </span><span class="mf">1.2</span><span class="p">],</span><span class="w"> </span><span class="n">autodiff</span><span class="o">=</span><span class="ss">:forward</span><span class="p">)</span>

<span class="n">println</span><span class="p">(</span><span class="s">&quot;converged=</span><span class="si">$</span><span class="p">(</span><span class="n">NLsolve</span><span class="o">.</span><span class="n">converged</span><span class="p">(</span><span class="n">results</span><span class="p">))</span><span class="s"> at root=</span><span class="si">$</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">zero</span><span class="p">)</span><span class="s"> in &quot;</span><span class="o">*</span>
<span class="s">&quot;</span><span class="si">$</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">iterations</span><span class="p">)</span><span class="s"> iterations and </span><span class="si">$</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">f_calls</span><span class="p">)</span><span class="s"> function calls&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>converged=true at root=[-3.487552479724522e-16, 1.0000000000000002] in 4 iterations and 5 function calls
</pre></div>
</div>
</div>
</div>
<p>Providing a function which operates inplace (i.e., modifies an argument) may help performance for large systems of equations (and hurt it for small ones).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span><span class="n">f!</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="c"># modifies the first argument</span>
<span class="w">    </span><span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span><span class="o">+</span><span class="mi">18</span>
<span class="w">    </span><span class="n">F</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nlsolve</span><span class="p">(</span><span class="n">f!</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="mf">0.1</span><span class="p">;</span><span class="w"> </span><span class="mf">1.2</span><span class="p">],</span><span class="w"> </span><span class="n">autodiff</span><span class="o">=</span><span class="ss">:forward</span><span class="p">)</span>

<span class="n">println</span><span class="p">(</span><span class="s">&quot;converged=</span><span class="si">$</span><span class="p">(</span><span class="n">NLsolve</span><span class="o">.</span><span class="n">converged</span><span class="p">(</span><span class="n">results</span><span class="p">))</span><span class="s"> at root=</span><span class="si">$</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">zero</span><span class="p">)</span><span class="s"> in &quot;</span><span class="o">*</span>
<span class="s">&quot;</span><span class="si">$</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">iterations</span><span class="p">)</span><span class="s"> iterations and </span><span class="si">$</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">f_calls</span><span class="p">)</span><span class="s"> function calls&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>converged=true at root=[-3.487552479724522e-16, 1.0000000000000002] in 4 iterations and 5 function calls
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="leastsquaresoptim-jl">
<h2><a class="toc-backref" href="#id6"><span class="section-number">9.5. </span>LeastSquaresOptim.jl</a><a class="headerlink" href="#leastsquaresoptim-jl" title="Permalink to this headline">¶</a></h2>
<p>Many optimization problems can be solved using linear or nonlinear least squares.</p>
<p>Let <span class="math notranslate nohighlight">\(x \in R^N\)</span> and <span class="math notranslate nohighlight">\(F(x) : R^N \to R^M\)</span> with <span class="math notranslate nohighlight">\(M \geq N\)</span>, then the nonlinear least squares problem is</p>
<div class="math notranslate nohighlight">
\[
\min_x F(x)^T F(x)
\]</div>
<p>While <span class="math notranslate nohighlight">\(F(x)^T F(x) \to R\)</span>, and hence this problem could technically use any nonlinear optimizer, it is useful to exploit the structure of the problem.</p>
<p>In particular, the Jacobian of <span class="math notranslate nohighlight">\(F(x)\)</span>, can be used to approximate the Hessian of the objective.</p>
<p>As with most nonlinear optimization problems, the benefits will typically become evident only when analytical or automatic differentiation is possible.</p>
<p>If <span class="math notranslate nohighlight">\(M = N\)</span> and we know a root <span class="math notranslate nohighlight">\(F(x^*) = 0\)</span> to the system of equations exists, then NLS is the defacto method for solving large <strong>systems of equations</strong>.</p>
<p>An implementation of NLS is given in <a class="reference external" href="https://github.com/matthieugomez/LeastSquaresOptim.jl">LeastSquaresOptim.jl</a>.</p>
<p>From the documentation</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">LeastSquaresOptim</span>
<span class="k">function</span><span class="w"> </span><span class="n">rosenbrock</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">^</span><span class="mi">2</span><span class="p">)]</span>
<span class="k">end</span>
<span class="n">LeastSquaresOptim</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">rosenbrock</span><span class="p">,</span><span class="w"> </span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">Dogleg</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Results of Optimization Algorithm
 * Algorithm: Dogleg
 * Minimizer: [1.0,1.0]
 * Sum of squares at Minimum: 0.000000
 * Iterations: 51
 * Convergence: true
 * |x - x&#39;| &lt; 1.0e-08: false
 * |f(x) - f(x&#39;)| / |f(x)| &lt; 1.0e-08: true
 * |g(x)| &lt; 1.0e-08: false
 * Function Calls: 52
 * Gradient Calls: 36
 * Multiplication Calls: 159
</pre></div>
</div>
</div>
</div>
<p><strong>Note:</strong> Because there is a name clash between <code class="docutils literal notranslate"><span class="pre">Optim.jl</span></code> and this package, to use both we need to qualify the use of the <code class="docutils literal notranslate"><span class="pre">optimize</span></code> function (i.e. <code class="docutils literal notranslate"><span class="pre">LeastSquaresOptim.optimize</span></code>).</p>
<p>Here, by default it will use AD with <code class="docutils literal notranslate"><span class="pre">ForwardDiff.jl</span></code> to calculate the Jacobian,
but you could also provide your own calculation of the Jacobian (analytical or using finite differences) and/or calculate the function inplace.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span><span class="n">rosenbrock_f!</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="w">    </span><span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
<span class="k">end</span>
<span class="n">LeastSquaresOptim</span><span class="o">.</span><span class="n">optimize!</span><span class="p">(</span><span class="n">LeastSquaresProblem</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
<span class="w">                                </span><span class="n">f!</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rosenbrock_f!</span><span class="p">,</span><span class="w"> </span><span class="n">output_length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span>

<span class="c"># if you want to use gradient</span>
<span class="k">function</span><span class="w"> </span><span class="n">rosenbrock_g!</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="n">J</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span>
<span class="w">    </span><span class="n">J</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="n">J</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">200</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="w">    </span><span class="n">J</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span>
<span class="k">end</span>
<span class="n">LeastSquaresOptim</span><span class="o">.</span><span class="n">optimize!</span><span class="p">(</span><span class="n">LeastSquaresProblem</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
<span class="w">                                </span><span class="n">f!</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rosenbrock_f!</span><span class="p">,</span><span class="w"> </span><span class="n">g!</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rosenbrock_g!</span><span class="p">,</span><span class="w"> </span><span class="n">output_length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Results of Optimization Algorithm
 * Algorithm: Dogleg
 * Minimizer: [1.0,1.0]
 * Sum of squares at Minimum: 0.000000
 * Iterations: 51
 * Convergence: true
 * |x - x&#39;| &lt; 1.0e-08: false
 * |f(x) - f(x&#39;)| / |f(x)| &lt; 1.0e-08: true
 * |g(x)| &lt; 1.0e-08: false
 * Function Calls: 52
 * Gradient Calls: 36
 * Multiplication Calls: 159
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="additional-notes">
<h2><a class="toc-backref" href="#id7"><span class="section-number">9.6. </span>Additional Notes</a><a class="headerlink" href="#additional-notes" title="Permalink to this headline">¶</a></h2>
<p>Watch <a class="reference external" href="https://www.youtube.com/watch?v=vAp6nUMrKYg&amp;feature=youtu.be">this video</a> from one of Julia’s creators on automatic differentiation.</p>
</div>
<div class="section" id="exercises">
<h2><a class="toc-backref" href="#id8"><span class="section-number">9.7. </span>Exercises</a><a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<div class="section" id="exercise-1">
<h3><span class="section-number">9.7.1. </span>Exercise 1<a class="headerlink" href="#exercise-1" title="Permalink to this headline">¶</a></h3>
<p>Doing a simple implementation of forward-mode auto-differentiation is very easy in Julia since it is generic.  In this exercise, you
will fill in a few of the operations required for a simple AD implementation.</p>
<p>First, we need to provide a type to hold the dual.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="kt">DualNumber</span><span class="p">{</span><span class="kt">T</span><span class="p">}</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="kt">Real</span>
<span class="w">    </span><span class="n">val</span><span class="o">::</span><span class="kt">T</span>
<span class="w">    </span><span class="n">ϵ</span><span class="o">::</span><span class="kt">T</span>
<span class="k">end</span>
</pre></div>
</div>
</div>
</div>
<p>Here we have made it a subtype of <code class="docutils literal notranslate"><span class="pre">Real</span></code> so that it can pass through functions expecting Reals.</p>
<p>We can add on a variety of chain rule definitions by importing in the appropriate functions and adding DualNumber versions.  For example</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="n">Base</span><span class="o">:</span><span class="w"> </span><span class="o">+</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="p">,</span><span class="w"> </span><span class="o">^</span><span class="p">,</span><span class="w"> </span><span class="n">exp</span>
<span class="o">+</span><span class="p">(</span><span class="n">x</span><span class="o">::</span><span class="kt">DualNumber</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">::</span><span class="kt">DualNumber</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DualNumber</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">val</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="o">.</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="n">ϵ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="o">.</span><span class="n">ϵ</span><span class="p">)</span><span class="w">  </span><span class="c"># dual addition</span>
<span class="o">+</span><span class="p">(</span><span class="n">x</span><span class="o">::</span><span class="kt">DualNumber</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="o">::</span><span class="kt">Number</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DualNumber</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">val</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="n">ϵ</span><span class="p">)</span><span class="w">  </span><span class="c"># i.e. scalar addition, not dual</span>
<span class="o">+</span><span class="p">(</span><span class="n">a</span><span class="o">::</span><span class="kt">Number</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="o">::</span><span class="kt">DualNumber</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DualNumber</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">val</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="n">ϵ</span><span class="p">)</span><span class="w">  </span><span class="c"># i.e. scalar addition, not dual</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>+ (generic function with 353 methods)
</pre></div>
</div>
</div>
</div>
<p>With that, we can seed a dual number and find simple derivatives,</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>

<span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DualNumber</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">)</span><span class="w">  </span><span class="c"># x -&gt; 2.0 + 1.0\epsilon</span>
<span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DualNumber</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w">  </span><span class="c"># i.e. y = 3.0, no derivative</span>


<span class="c"># seeded calculates both teh function and the d/dx gradient!</span>
<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>DualNumber{Float64}(8.0, 1.0)
</pre></div>
</div>
</div>
</div>
<p>For this assignment:</p>
<ol class="simple">
<li><p>Add in AD rules for the other operations: <code class="docutils literal notranslate"><span class="pre">*,</span> <span class="pre">-,</span> <span class="pre">^,</span> <span class="pre">exp</span></code>.</p></li>
<li><p>Come up with some examples of univariate and multivariate functions combining those operations and use your AD implementation to find the derivatives.</p></li>
</ol>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "julia-1.8"
        },
        kernelOptions: {
            kernelName: "julia-1.8",
            path: "./more_julia"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'julia-1.8'</script>

                    </div>
                    
                </main> <!-- .page__content -->
                


                <footer class="qe-page__footer">

                    <p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><img src="https://licensebuttons.net/l/by-sa/4.0/80x15.png"></a></p>

                    <p>Creative Commons License &ndash; This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International.</p>

                </footer> <!-- .page__footer -->

            </div> <!-- .page -->

            

            
            <div class="qe-sidebar bd-sidebar inactive" id="site-navigation">

                <div class="qe-sidebar__header">


                    Contents

                </div>

                <nav class="qe-sidebar__nav" id="qe-sidebar-nav" aria-label="Main navigation">
                    <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Getting Started with Julia
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../getting_started_julia/getting_started.html">
   1. Setting up Your Julia Environment
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../getting_started_julia/julia_by_example.html">
   2. Introductory Examples
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../getting_started_julia/julia_essentials.html">
   3. Julia Essentials
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../getting_started_julia/fundamental_types.html">
   4. Arrays, Tuples, Ranges, and Other Fundamental Types
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../getting_started_julia/introduction_to_types.html">
   5. Introduction to Types and Generic Programming
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Package Ecosystem
 </span>
</p>
<ul class="current nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="generic_programming.html">
   6. Generic Programming
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="general_packages.html">
   7. General Purpose Packages
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="data_statistical_packages.html">
   8. Data and Statistics Packages
  </a>
 </li>
 <li class="toctree-l1 current active active">
  <a class="current reference internal" href="#">
   9. Solvers, Optimizers, and Automatic Differentiation
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Software Engineering
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../software_engineering/tools_editors.html">
   10. Visual Studio Code and Other Tools
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../software_engineering/version_control.html">
   11. GitHub, Version Control and Collaboration
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../software_engineering/testing.html">
   12. Packages, Testing, and Continuous Integration
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../software_engineering/need_for_speed.html">
   13. The Need for Speed
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Tools and Techniques
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../tools_and_techniques/geom_series.html">
   14. Geometric Series for Elementary Economics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../tools_and_techniques/linear_algebra.html">
   15. Linear Algebra
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../tools_and_techniques/orth_proj.html">
   16. Orthogonal Projections and Their Applications
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../tools_and_techniques/lln_clt.html">
   17. LLN and CLT
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../tools_and_techniques/stationary_densities.html">
   18. Continuous State Markov Chains
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../tools_and_techniques/numerical_linear_algebra.html">
   19. Numerical Linear Algebra and Factorizations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../tools_and_techniques/iterative_methods_sparsity.html">
   20. Krylov Methods and Matrix Conditioning
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Introduction to Dynamics
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../introduction_dynamics/scalar_dynam.html">
   21. Dynamics in One Dimension
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../introduction_dynamics/ar1_processes.html">
   22. AR1 Processes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../introduction_dynamics/finite_markov.html">
   23. Finite Markov Chains
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../introduction_dynamics/linear_models.html">
   24. Linear State Space Models
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../introduction_dynamics/wealth_dynamics.html">
   25. Wealth Distribution Dynamics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../introduction_dynamics/kalman.html">
   26. A First Look at the Kalman Filter
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../introduction_dynamics/short_path.html">
   27. Shortest Paths
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Dynamic Programming
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/mccall_model.html">
   28. Job Search I: The McCall Search Model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/mccall_model_with_separation.html">
   29. Job Search II: Search and Separation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/wald_friedman.html">
   30. A Problem that Stumped Milton Friedman
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/odu.html">
   31. Job Search III: Search with Learning
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/career.html">
   32. Job Search IV: Modeling Career Choice
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/jv.html">
   33. Job Search V: On-the-Job Search
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/optgrowth.html">
   34. Optimal Growth I: The Stochastic Optimal Growth Model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/coleman_policy_iter.html">
   35. Optimal Growth II: Time Iteration
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/egm_policy_iter.html">
   36. Optimal Growth III: The Endogenous Grid Method
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/lqcontrol.html">
   37. LQ Dynamic Programming Problems
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/perm_income.html">
   38. Optimal Savings I: The Permanent Income Model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/perm_income_cons.html">
   39. Optimal Savings II: LQ Techniques
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/smoothing.html">
   40. Consumption and Tax Smoothing with Complete and Incomplete Markets
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/ifp.html">
   41. Optimal Savings III: Occasionally Binding Constraints
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/robustness.html">
   42. Robustness
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/discrete_dp.html">
   43. Discrete State Dynamic Programming
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Modeling in Continuous Time
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../continuous_time/seir_model.html">
   44. Modeling COVID 19 with Differential Equations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../continuous_time/covid_sde.html">
   45. Modeling Shocks in COVID 19 with Stochastic Differential Equations
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Multiple Agent Models
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../multi_agent_models/schelling.html">
   46. Schelling’s Segregation Model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../multi_agent_models/lake_model.html">
   47. A Lake Model of Employment and Unemployment
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../multi_agent_models/rational_expectations.html">
   48. Rational Expectations Equilibrium
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../multi_agent_models/markov_perf.html">
   49. Markov Perfect Equilibrium
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../multi_agent_models/markov_asset.html">
   50. Asset Pricing I: Finite State Models
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../multi_agent_models/lucas_model.html">
   51. Asset Pricing II: The Lucas Asset Pricing Model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../multi_agent_models/harrison_kreps.html">
   52. Asset Pricing III:  Incomplete Markets
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../multi_agent_models/uncertainty_traps.html">
   53. Uncertainty Traps
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../multi_agent_models/aiyagari.html">
   54. The Aiyagari Model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../multi_agent_models/arellano.html">
   55. Default Risk and Income Fluctuations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../multi_agent_models/matsuyama.html">
   56. Globalization and Cycles
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Time Series Models
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../time_series_models/arma.html">
   57. Covariance Stationary Processes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../time_series_models/estspec.html">
   58. Estimation of Spectra
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../time_series_models/additive_functionals.html">
   59. Additive Functionals
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../time_series_models/multiplicative_functionals.html">
   60. Multiplicative Functionals
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../time_series_models/lu_tricks.html">
   61. Classical Control with Linear Algebra
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../time_series_models/classical_filtering.html">
   62. Classical Filtering With Linear Algebra
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Dynamic Programming Squared
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming_squared/dyn_stack.html">
   63. Dynamic Stackelberg Problems
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming_squared/lqramsey.html">
   64. Optimal Taxation in an LQ Economy
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming_squared/opt_tax_recur.html">
   65. Optimal Taxation with State-Contingent Debt
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming_squared/amss.html">
   66. Optimal Taxation without State-Contingent Debt
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Other
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../about_lectures.html">
   67. About these Lectures
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../troubleshooting.html">
   68. Troubleshooting
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../zreferences.html">
   69. References
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../status.html">
   70. Execution Statistics
  </a>
 </li>
</ul>

                </nav>

                <div class="qe-sidebar__footer">

                </div>

            </div> <!-- .sidebar -->
            
        </div> <!-- .main -->

        <div class="qe-toolbar">

            <div class="qe-toolbar__inner">

                <ul class="qe-toolbar__main">
                    <li data-tippy-content="Table of Contents" class="btn__sidebar"><i data-feather="menu"></i></li>
                    <li data-tippy-content="Home"><a href="../intro.html"><i data-feather="home"></i></a></li>
                    <li class="btn__qelogo"><a href="https://quantecon.org" title=""><span class="show-for-sr">QuantEcon</span></a></li>
                    <!-- <li class="btn__search">
                        <form action="../search.html" method="get">
                            <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off">
                            <i data-feather="search"></i>
                        </form>
                    </li> -->
                </ul>

                <ul class="qe-toolbar__links">
                    <li data-tippy-content="Fullscreen" class="btn__fullscreen"><i data-feather="maximize"></i></li>
                    <li data-tippy-content="Increase font size" class="btn__plus"><i data-feather="plus-circle"></i></li>
                    <li data-tippy-content="Decrease font size" class="btn__minus"><i data-feather="minus-circle"></i></li>
                    <li data-tippy-content="Change contrast" class="btn__contrast"><i data-feather="sunset"></i></li>
                    <li data-tippy-content="Download Notebook"><a href="/_notebooks/more_julia/optimization_solver_packages.ipynb" download><i data-feather="download-cloud"></i></a></li>
                    <li class="settings-button" id="settingsButton"><div data-tippy-content="Launch Notebook"><i data-feather="play-circle"></i></div></li>
                        <li data-tippy-content="Download PDF" onClick="window.print()"><i data-feather="file"></i></li>
                    <li data-tippy-content="View Source"><a target="_blank" href="https://github.com/QuantEcon/lecture-julia.myst/tree/main/lectures/more_julia/optimization_solver_packages.md" download><i data-feather="github"></i></a></li>
                </ul>

            </div>

        </div> <!-- .toolbar -->
        <div id="downloadPDFModal" style="display: none;">
            <ul class="pdf-options" style="display: block;">
                <li class="download-pdf-book" onClick="window.print()">
                    <p>Lecture (PDF)</p>
                </li>
                <li class="download-pdf-file">
                    <a href="" download><p>Book (PDF)</p></a>
                </li>
            </ul>
        </div>
        <div id="settingsModal" style="display: none;">
            <p class="modal-title"> Notebook Launcher </p>
            <div class="modal-desc">
            <p>
                Choose public or private cloud service for "Launch" button.
            </p>
            </div>
            <p class="modal-subtitle">Select a server</p>
            <ul class="modal-servers">
            <li class="active launcher-public">
                <span class="label">Public</span>
                <select id="launcher-public-input">
                
                    <option value="https://mybinder.org/v2/gh/QuantEcon/lecture-julia.notebooks/main?urlpath=tree/more_julia/optimization_solver_packages.ipynb">BinderHub</option>
                
                </select>
                <i class="fas fa-check-circle"></i>
            </li>
            <li class="launcher-private">
                <span class="label">Private</span>
                <input type="text" id="launcher-private-input" data-repourl="https://github.com/QuantEcon/lecture-julia.notebooks" data-urlpath="tree/lecture-julia.notebooks/more_julia/optimization_solver_packages.ipynb" data-branch=main>
                <i class="fas fa-check-circle"></i>
            </li>
            </ul>
            <p class="launch"><a href="https://mybinder.org/v2/gh/QuantEcon/lecture-julia.notebooks/main?urlpath=tree/more_julia/optimization_solver_packages.ipynb" id="advancedLaunchButton" target="_blank">Launch Notebook</a></p>
            <script>
                // QuantEcon Notebook Launcher
                const launcherTypeElements = document.querySelectorAll('#settingsModal .modal-servers li');
                // Highlight the server type if previous selection exists
                if (typeof localStorage.launcherType !== 'undefined') {
                  for (var i = 0; i < launcherTypeElements.length; i++) {
                    launcherTypeElements[i].classList.remove('active');
                    if ( launcherTypeElements[i].classList.contains(localStorage.launcherType) ) {
                      launcherTypeElements[i].classList.add('active');
                    }
                  }
                }
                // Highlight server type on click and set local storage value
                for (var i = 0; i < launcherTypeElements.length; i++) {
                  launcherTypeElements[i].addEventListener('click', function() {
                    for (var j = 0; j < launcherTypeElements.length; j++) {
                      launcherTypeElements[j].classList.remove('active');
                    }
                    this.classList.add('active');
                    if ( this.classList.contains('launcher-private') ) {
                      localStorage.launcherType = 'launcher-private';
                    } else if ( this.classList.contains('launcher-public') ) {
                      localStorage.launcherType = 'launcher-public';
                    }
                    setLaunchServer();
                  })
                }
                const launcherPublic = document.getElementById('launcher-public-input');
                const launcherPrivate = document.getElementById('launcher-private-input');
                const pageName = "more_julia/optimization_solver_packages";
                const repoURL = "https://github.com/QuantEcon/lecture-julia.notebooks";
                const urlPath = "tree/lecture-julia.notebooks/more_julia/optimization_solver_packages.ipynb";
                const branch = "main"
                const launchNotebookLink = document.getElementById('advancedLaunchButton');

                // Highlight public server option if previous selection exists
                if (typeof localStorage.launcherPublic !== 'undefined') {
                  launcherPublic.value = localStorage.launcherPublic;
                }
                // Update local storage upon public server selection
                launcherPublic.addEventListener('change', (event) => {
                  setLaunchServer();
                });
                // Populate private server input if previous entry exists
                if (typeof localStorage.launcherPrivate !== 'undefined') {
                  launcherPrivate.value = localStorage.launcherPrivate;
                }
                // Update local storage when a private server is entered
                launcherPrivate.addEventListener('input', (event) => {
                  setLaunchServer();
                });

                // Function to update the "Launch Notebook" link href
                function setLaunchServer() {
                  launchNotebookLink.removeAttribute("style")
                  if ( localStorage.launcherType == 'launcher-private' ) {
                    let repoPrefix = "/jupyter/hub/user-redirect/git-pull?repo=" + repoURL + "&branch=" + branch + "&urlpath=" + urlPath;
                    launcherPrivateValue = launcherPrivate.value
                    if (!launcherPrivateValue) {
                        launchNotebookLink.removeAttribute("href")
                        launchNotebookLink.style.background = "grey"
                        return
                    }
                    localStorage.launcherPrivate = launcherPrivateValue;
                    privateServer = localStorage.launcherPrivate.replace(/\/$/, "")
                    if (!privateServer.includes("http")) {
                        privateServer = "http://" + privateServer
                    }
                    launchNotebookLinkURL = privateServer + repoPrefix;
                  } else if ( localStorage.launcherType == 'launcher-public' ) {
                    launcherPublicValue = launcherPublic.options[launcherPublic.selectedIndex].value;
                    localStorage.launcherPublic = launcherPublicValue;
                    launchNotebookLinkURL = localStorage.launcherPublic;
                  }
                  if (launchNotebookLinkURL) launchNotebookLink.href = launchNotebookLinkURL;
                }
                // Check if user has previously selected a server
                if ( (typeof localStorage.launcherPrivate !== 'undefined') || (typeof localStorage.launcherPublic !== 'undefined') ) {
                  setLaunchServer();
                }
                </script>

        </div>

    </div> <!-- .wrapper-->
    
<script async="" src="https://www.google-analytics.com/analytics.js"></script>
<script>
                        window.ga = window.ga || function () {
                            (ga.q = ga.q || []).push(arguments) };
                        ga.l = +new Date;
                        ga('create', 'UA-54984338-8', 'auto');
                        ga('set', 'anonymizeIp', true);
                        ga('send', 'pageview');
                    </script>

  </body>
</html>