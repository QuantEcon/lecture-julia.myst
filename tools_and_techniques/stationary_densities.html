
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>20. Continuous State Markov Chains &#8212; Quantitative Economics with Julia</title>
    <script src="https://unpkg.com/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
    <script src="https://unpkg.com/tippy.js@6.3.1/dist/tippy-bundle.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
    
        <script>
            MathJax = {
            loader: {load: ['[tex]/boldsymbol']},
            tex: {
                packages: {'[+]': ['boldsymbol']},
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                processEscapes: true,
                macros: {
                    "argmax" : "arg\\,max",
                    "argmin" : "arg\\,min",
                    "col"    : "col",
                    "Span"   :  "span",
                    "epsilon": "\\varepsilon",
                    "EE": "\\mathbb{E}",
                    "PP": "\\mathbb{P}",
                    "RR": "\\mathbb{R}",
                    "NN": "\\mathbb{N}",
                    "ZZ": "\\mathbb{Z}",
                    "aA": "\\mathcal{A}",
                    "bB": "\\mathcal{B}",
                    "cC": "\\mathcal{C}",
                    "dD": "\\mathcal{D}",
                    "eE": "\\mathcal{E}",
                    "fF": "\\mathcal{F}",
                    "gG": "\\mathcal{G}",
                    "hH": "\\mathcal{H}",
                }
            },
            svg: {
                fontCache: 'global',
                scale: 0.92,
                displayAlign: "center",
            },
            };
        </script>
    
    
    
  <link href="../_static/css/theme.css" rel="stylesheet" />
  <link href="../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/quantecon-book-theme.857ff391aaabaeb8c161d2309c375fe6.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.1c5a1a01449ed65a7b51.js">


    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script src="../_static/quantecon-book-theme.76bf49d7bbc59738cdb03766fad654af.js"></script>
    <script async="async" src="https://unpkg.com/thebe@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-svg.js"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"argmax": "arg\\,max", "argmin": "arg\\,min"}}, "tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <link rel="canonical" href="https://julia.quantecon.org/tools_and_techniques/stationary_densities.html" />
    <link rel="shortcut icon" href="../_static/lectures-favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="21. A First Look at the Kalman Filter" href="kalman.html" />
    <link rel="prev" title="19. Finite Markov Chains" href="finite_markov.html" />

<!-- Normal Meta Tags -->
<meta name="author" context="Jesse Perla &amp; Thomas J. Sargent &amp; John Stachurski" />
<meta name="keywords" content="Julia, QuantEcon, Quantitative Economics, Economics, Sloan, Alfred P. Sloan Foundation, Tom J. Sargent, John Stachurski" />
<meta name="description" content=This website presents a set of lectures on quantitative economic modeling, designed and written by Jesse Perla, Thomas J. Sargent and John Stachurski. The language instruction is Julia. />

<!-- Twitter tags -->
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@quantecon" />
<meta name="twitter:title" content="Continuous State Markov Chains"/>
<meta name="twitter:description" content="This website presents a set of lectures on quantitative economic modeling, designed and written by Jesse Perla, Thomas J. Sargent and John Stachurski. The language instruction is Julia.">
<meta name="twitter:creator" content="@quantecon">
<meta name="twitter:image" content="https://assets.quantecon.org/img/qe-twitter-logo.png">

<!-- Opengraph tags -->
<meta property="og:title" content="Continuous State Markov Chains" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://julia.quantecon.org/tools_and_techniques/stationary_densities.html" />
<meta property="og:image" content="https://assets.quantecon.org/img/qe-og-logo.png" />
<meta property="og:description" content="This website presents a set of lectures on quantitative economic modeling, designed and written by Jesse Perla, Thomas J. Sargent and John Stachurski. The language instruction is Julia." />
<meta property="og:site_name" content="Quantitative Economics with Julia" />
<meta name="theme-color" content="#ffffff" />

  </head>
<body>


    <span id="top"></span>

    <div class="wrapper">

        <div class="main">

            <div class="page" id=tools_and_techniques/stationary_densities>

                <div class="page__toc">

                    <div class="inner">

                        
                        <div class="page__toc-header">
                            On this page
                        </div>


                        <nav id="bd-toc-nav" class="page__toc-nav">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#overview">
   20.1. Overview
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-density-case">
   20.2. The Density Case
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#definitions-and-basic-properties">
     20.2.1. Definitions and Basic Properties
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#connection-to-stochastic-difference-equations">
     20.2.2. Connection to Stochastic Difference Equations
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#distribution-dynamics">
     20.2.3. Distribution Dynamics
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#computation">
     20.2.4. Computation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#implementation">
     20.2.5. Implementation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#example">
     20.2.6. Example
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#beyond-densities">
   20.3. Beyond Densities
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#example-and-definitions">
     20.3.1. Example and Definitions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id4">
     20.3.2. Computation
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#stability">
   20.4. Stability
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#theoretical-results">
     20.4.1. Theoretical Results
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#an-example-of-stability">
     20.4.2. An Example of Stability
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#computing-stationary-densities">
     20.4.3. Computing Stationary Densities
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercises">
   20.5. Exercises
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-1">
     20.5.1. Exercise 1
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-2">
     20.5.2. Exercise 2
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise-3">
     20.5.3. Exercise 3
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#solutions">
   20.6. Solutions
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id8">
     20.6.1. Exercise 1
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id9">
     20.6.2. Exercise 2
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id10">
     20.6.3. Exercise 3
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#appendix">
   20.7. Appendix
  </a>
 </li>
</ul>

                            <p class="logo">
                                
                                    
                                    <a href=https://quantecon.org><img src="../_static/qe-logo-large.png" class="logo" alt="logo"></a>
                                    
                                
                            </p>

                            <p class="powered">Powered by <a href="https://jupyterbook.org/">Jupyter Book</a></p>

                        </nav>

                        <div class="page__toc-footer">
                            
                            
                            <p><a href="#top"><strong>Back to top</strong></a></p>
                        </div>

                    </div>

                </div>

                <div class="page__header">

                    <div class="page__header-copy">

                        <p class="page__header-heading"><a href="intro.html">Quantitative Economics with Julia</a></p>

                        <p class="page__header-subheading">Continuous State Markov Chains</p>

                    </div>

                    <p class="page__header-authors">Jesse Perla & Thomas J. Sargent & John Stachurski</p>

                </div> <!-- .page__header -->



                
                <main class="page__content" role="main">
                    
                    <div>
                        
  <div id="qe-notebook-header" style="text-align:right;">
        <a href="https://quantecon.org/" title="quantecon.org">
                <img style="width:250px;display:inline;" src="https://assets.quantecon.org/img/qe-menubar-logo.svg" alt="QuantEcon">
        </a>
</div><div class="section" id="continuous-state-markov-chains">
<h1><a class="toc-backref" href="#id11"><span class="section-number">20. </span><span class="target" id="index-0"></span>Continuous State Markov Chains</a><a class="headerlink" href="#continuous-state-markov-chains" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<span id="index-1"></span><p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#continuous-state-markov-chains" id="id11">Continuous State Markov Chains</a></p>
<ul>
<li><p><a class="reference internal" href="#overview" id="id12">Overview</a></p></li>
<li><p><a class="reference internal" href="#the-density-case" id="id13">The Density Case</a></p></li>
<li><p><a class="reference internal" href="#beyond-densities" id="id14">Beyond Densities</a></p></li>
<li><p><a class="reference internal" href="#stability" id="id15">Stability</a></p></li>
<li><p><a class="reference internal" href="#exercises" id="id16">Exercises</a></p></li>
<li><p><a class="reference internal" href="#solutions" id="id17">Solutions</a></p></li>
<li><p><a class="reference internal" href="#appendix" id="id18">Appendix</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="overview">
<h2><a class="toc-backref" href="#id12"><span class="section-number">20.1. </span>Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>In a <a class="reference internal" href="finite_markov.html"><span class="doc">previous lecture</span></a> we learned about finite Markov chains, a relatively elementary class of stochastic dynamic models.</p>
<p>The present lecture extends this analysis to continuous (i.e., uncountable) state Markov chains.</p>
<p>Most stochastic dynamic models studied by economists either fit directly into this class or can be represented as continuous state Markov chains after minor modifications.</p>
<p>In this lecture, our focus will be on continuous Markov models that</p>
<ul class="simple">
<li><p>evolve in discrete time</p></li>
<li><p>are often nonlinear</p></li>
</ul>
<p>The fact that we accommodate nonlinear models here is significant, because
linear stochastic models have their own highly developed tool set, as we’ll
see <a class="reference internal" href="../time_series_models/arma.html"><span class="doc">later on</span></a>.</p>
<p>The question that interests us most is: Given a particular stochastic dynamic
model, how will the state of the system evolve over time?</p>
<p>In particular,</p>
<ul class="simple">
<li><p>What happens to the distribution of the state variables?</p></li>
<li><p>Is there anything we can say about the “average behavior” of these variables?</p></li>
<li><p>Is there a notion of “steady state” or “long run equilibrium” that’s applicable to the model?</p>
<ul>
<li><p>If so, how can we compute it?</p></li>
</ul>
</li>
</ul>
<p>Answering these questions will lead us to revisit many of the topics that occupied us in the finite state case,
such as simulation, distribution dynamics, stability, ergodicity, etc.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For some people, the term “Markov chain” always refers to a process with a
finite or discrete state space.  We follow the mainstream
mathematical literature (e.g., <span id="id1">[<a class="reference internal" href="../zreferences.html#id109">MT09</a>]</span>) in using the term to refer to any discrete <strong>time</strong>
Markov process.</p>
</div>
<div class="cell tag_hide-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">LinearAlgebra</span><span class="p">,</span> <span class="n">Statistics</span>
<span class="k">using</span> <span class="n">KernelDensity</span><span class="p">,</span> <span class="n">Distributions</span><span class="p">,</span> <span class="n">Plots</span><span class="p">,</span> <span class="n">QuantEcon</span><span class="p">,</span> <span class="n">Random</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="the-density-case">
<span id="statd-density-case"></span><h2><a class="toc-backref" href="#id13"><span class="section-number">20.2. </span>The Density Case</a><a class="headerlink" href="#the-density-case" title="Permalink to this headline">¶</a></h2>
<p>You are probably aware that some distributions can be represented by densities
and some cannot.</p>
<p>(For example, distributions on the real numbers <span class="math notranslate nohighlight">\(\mathbb R\)</span> that put positive probability
on individual points have no density representation)</p>
<p>We are going to start our analysis by looking at Markov chains where the one step transition probabilities have density representations.</p>
<p>The benefit is that the density case offers a very direct parallel to the finite case in terms of notation and intuition.</p>
<p>Once we’ve built some intuition we’ll cover the general case.</p>
<div class="section" id="definitions-and-basic-properties">
<h3><span class="section-number">20.2.1. </span>Definitions and Basic Properties<a class="headerlink" href="#definitions-and-basic-properties" title="Permalink to this headline">¶</a></h3>
<p>In our <a class="reference internal" href="finite_markov.html"><span class="doc">lecture on finite Markov chains</span></a>, we studied discrete time Markov chains that evolve on a finite state space <span class="math notranslate nohighlight">\(S\)</span>.</p>
<p>In this setting, the dynamics of the model are described by a stochastic matrix — a nonnegative square matrix <span class="math notranslate nohighlight">\(P = P[i, j]\)</span> such that each row <span class="math notranslate nohighlight">\(P[i, \cdot]\)</span> sums to one.</p>
<p>The interpretation of <span class="math notranslate nohighlight">\(P\)</span> is that <span class="math notranslate nohighlight">\(P[i, j]\)</span> represents the
probability of transitioning from state <span class="math notranslate nohighlight">\(i\)</span> to state <span class="math notranslate nohighlight">\(j\)</span> in one
unit of time.</p>
<p>In symbols,</p>
<div class="math notranslate nohighlight">
\[
\mathbb P \{ X_{t+1} = j \,|\, X_t = i \} = P[i, j]
\]</div>
<p>Equivalently,</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(P\)</span> can be thought of as a family of distributions <span class="math notranslate nohighlight">\(P[i, \cdot]\)</span>, one for each <span class="math notranslate nohighlight">\(i \in S\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(P[i, \cdot]\)</span> is the distribution of <span class="math notranslate nohighlight">\(X_{t+1}\)</span> given <span class="math notranslate nohighlight">\(X_t = i\)</span></p></li>
</ul>
<p>(As you probably recall, when using Julia arrays, <span class="math notranslate nohighlight">\(P[i, \cdot]\)</span> is expressed as <code class="docutils literal notranslate"><span class="pre">P[i,:]</span></code>)</p>
<p>In this section, we’ll allow <span class="math notranslate nohighlight">\(S\)</span> to be a subset of <span class="math notranslate nohighlight">\(\mathbb R\)</span>, such as</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbb R\)</span> itself</p></li>
<li><p>the positive reals <span class="math notranslate nohighlight">\((0, \infty)\)</span></p></li>
<li><p>a bounded interval <span class="math notranslate nohighlight">\((a, b)\)</span></p></li>
</ul>
<p>The family of discrete distributions <span class="math notranslate nohighlight">\(P[i, \cdot]\)</span> will be replaced by a family of densities <span class="math notranslate nohighlight">\(p(x, \cdot)\)</span>, one for each <span class="math notranslate nohighlight">\(x \in S\)</span>.</p>
<p>Analogous to the finite state case, <span class="math notranslate nohighlight">\(p(x, \cdot)\)</span> is to be understood as the distribution (density) of <span class="math notranslate nohighlight">\(X_{t+1}\)</span> given <span class="math notranslate nohighlight">\(X_t = x\)</span>.</p>
<p>More formally, a <em>stochastic kernel on</em> <span class="math notranslate nohighlight">\(S\)</span> is a function <span class="math notranslate nohighlight">\(p \colon S \times S \to \mathbb R\)</span> with the property that</p>
<ol class="simple">
<li><p><span class="math notranslate nohighlight">\(p(x, y) \geq 0\)</span> for all <span class="math notranslate nohighlight">\(x, y \in S\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\int p(x, y) dy = 1\)</span> for all <span class="math notranslate nohighlight">\(x \in S\)</span></p></li>
</ol>
<p>(Integrals are over the whole space unless otherwise specified)</p>
<p>For example, let <span class="math notranslate nohighlight">\(S = \mathbb R\)</span> and consider the particular stochastic
kernel <span class="math notranslate nohighlight">\(p_w\)</span> defined by</p>
<div class="math notranslate nohighlight" id="equation-statd-rwsk">
<span class="eqno">(20.1)<a class="headerlink" href="#equation-statd-rwsk" title="Permalink to this equation">¶</a></span>\[p_w(x, y) := \frac{1}{\sqrt{2 \pi}} \exp \left\{ - \frac{(y - x)^2}{2} \right\}\]</div>
<p>What kind of model does <span class="math notranslate nohighlight">\(p_w\)</span> represent?</p>
<p>The answer is, the (normally distributed) random walk</p>
<div class="math notranslate nohighlight" id="equation-statd-rw">
<span class="eqno">(20.2)<a class="headerlink" href="#equation-statd-rw" title="Permalink to this equation">¶</a></span>\[X_{t+1} = X_t + \xi_{t+1}
\quad \text{where} \quad
\{ \xi_t \} \stackrel {\textrm{ IID }} {\sim} N(0, 1)\]</div>
<p>To see this, let’s find the stochastic kernel <span class="math notranslate nohighlight">\(p\)</span> corresponding to <a class="reference internal" href="#equation-statd-rw">(20.2)</a>.</p>
<p>Recall that <span class="math notranslate nohighlight">\(p(x, \cdot)\)</span> represents the distribution of <span class="math notranslate nohighlight">\(X_{t+1}\)</span> given <span class="math notranslate nohighlight">\(X_t = x\)</span>.</p>
<p>Letting <span class="math notranslate nohighlight">\(X_t = x\)</span> in <a class="reference internal" href="#equation-statd-rw">(20.2)</a> and considering the distribution of <span class="math notranslate nohighlight">\(X_{t+1}\)</span>, we see that <span class="math notranslate nohighlight">\(p(x, \cdot) = N(x, 1)\)</span>.</p>
<p>In other words, <span class="math notranslate nohighlight">\(p\)</span> is exactly <span class="math notranslate nohighlight">\(p_w\)</span>, as defined in <a class="reference internal" href="#equation-statd-rwsk">(20.1)</a>.</p>
</div>
<div class="section" id="connection-to-stochastic-difference-equations">
<h3><span class="section-number">20.2.2. </span>Connection to Stochastic Difference Equations<a class="headerlink" href="#connection-to-stochastic-difference-equations" title="Permalink to this headline">¶</a></h3>
<p>In the previous section, we made the connection between stochastic difference
equation <a class="reference internal" href="#equation-statd-rw">(20.2)</a> and stochastic kernel <a class="reference internal" href="#equation-statd-rwsk">(20.1)</a>.</p>
<p>In economics and time series analysis we meet stochastic difference equations of all different shapes and sizes.</p>
<p>It will be useful for us if we have some systematic methods for converting stochastic difference equations into stochastic kernels.</p>
<p>To this end, consider the generic (scalar) stochastic difference equation given by</p>
<div class="math notranslate nohighlight" id="equation-statd-srs">
<span class="eqno">(20.3)<a class="headerlink" href="#equation-statd-srs" title="Permalink to this equation">¶</a></span>\[X_{t+1} = \mu(X_t) + \sigma(X_t) \, \xi_{t+1}\]</div>
<p>Here we assume that</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\{ \xi_t \} \stackrel {\textrm{ IID }} {\sim} \phi\)</span>, where <span class="math notranslate nohighlight">\(\phi\)</span> is a given density on <span class="math notranslate nohighlight">\(\mathbb R\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\mu\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span> are given functions on <span class="math notranslate nohighlight">\(S\)</span>, with <span class="math notranslate nohighlight">\(\sigma(x) &gt; 0\)</span> for all <span class="math notranslate nohighlight">\(x\)</span></p></li>
</ul>
<p><strong>Example 1:</strong> The random walk <a class="reference internal" href="#equation-statd-rw">(20.2)</a> is a special case of <a class="reference internal" href="#equation-statd-srs">(20.3)</a>, with <span class="math notranslate nohighlight">\(\mu(x) = x\)</span> and <span class="math notranslate nohighlight">\(\sigma(x) = 1\)</span>.</p>
<p><strong>Example 2:</strong> Consider the <a class="reference external" href="https://en.wikipedia.org/wiki/Autoregressive_conditional_heteroskedasticity">ARCH model</a></p>
<div class="math notranslate nohighlight">
\[
X_{t+1} = \alpha X_t + \sigma_t \,  \xi_{t+1},
\qquad \sigma^2_t = \beta + \gamma X_t^2,
\qquad \beta, \gamma &gt; 0
\]</div>
<p>Alternatively, we can write the model as</p>
<div class="math notranslate nohighlight" id="equation-statd-arch">
<span class="eqno">(20.4)<a class="headerlink" href="#equation-statd-arch" title="Permalink to this equation">¶</a></span>\[X_{t+1} = \alpha X_t + (\beta + \gamma X_t^2)^{1/2} \xi_{t+1}\]</div>
<p>This is a special case of <a class="reference internal" href="#equation-statd-srs">(20.3)</a> with <span class="math notranslate nohighlight">\(\mu(x) = \alpha x\)</span> and <span class="math notranslate nohighlight">\(\sigma(x) = (\beta + \gamma x^2)^{1/2}\)</span>.</p>
<p id="solow-swan"><strong>Example 3:</strong> With stochastic production and a constant savings rate, the one-sector neoclassical growth model leads to a law of motion for capital per worker such as</p>
<div class="math notranslate nohighlight" id="equation-statd-ss">
<span class="eqno">(20.5)<a class="headerlink" href="#equation-statd-ss" title="Permalink to this equation">¶</a></span>\[k_{t+1} = s  A_{t+1} f(k_t) + (1 - \delta) k_t\]</div>
<p>Here</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(s\)</span> is the rate of savings</p></li>
<li><p><span class="math notranslate nohighlight">\(A_{t+1}\)</span> is a production shock</p>
<ul>
<li><p>The <span class="math notranslate nohighlight">\(t+1\)</span> subscript indicates that <span class="math notranslate nohighlight">\(A_{t+1}\)</span> is not visible at time <span class="math notranslate nohighlight">\(t\)</span></p></li>
</ul>
</li>
<li><p><span class="math notranslate nohighlight">\(\delta\)</span> is a depreciation rate</p></li>
<li><p><span class="math notranslate nohighlight">\(f \colon \mathbb R_+ \to \mathbb R_+\)</span> is a production function satisfying <span class="math notranslate nohighlight">\(f(k) &gt; 0\)</span> whenever <span class="math notranslate nohighlight">\(k &gt; 0\)</span></p></li>
</ul>
<p>(The fixed savings rate can be rationalized as the optimal policy for a particular set of technologies and preferences (see <span id="id2">[<a class="reference internal" href="../zreferences.html#id99">LS18</a>]</span>, section
3.1.2), although we omit the details here)</p>
<p>Equation <a class="reference internal" href="#equation-statd-ss">(20.5)</a> is a special case of <a class="reference internal" href="#equation-statd-srs">(20.3)</a> with <span class="math notranslate nohighlight">\(\mu(x) = (1 - \delta)x\)</span> and <span class="math notranslate nohighlight">\(\sigma(x) = s f(x)\)</span>.</p>
<p>Now let’s obtain the stochastic kernel corresponding to the generic model <a class="reference internal" href="#equation-statd-srs">(20.3)</a>.</p>
<p>To find it, note first that if <span class="math notranslate nohighlight">\(U\)</span> is a random variable with
density <span class="math notranslate nohighlight">\(f_U\)</span>, and <span class="math notranslate nohighlight">\(V = a + b U\)</span> for some constants <span class="math notranslate nohighlight">\(a,b\)</span>
with <span class="math notranslate nohighlight">\(b &gt; 0\)</span>, then the density of <span class="math notranslate nohighlight">\(V\)</span> is given by</p>
<div class="math notranslate nohighlight" id="equation-statd-dv">
<span class="eqno">(20.6)<a class="headerlink" href="#equation-statd-dv" title="Permalink to this equation">¶</a></span>\[f_V(v)
= \frac{1}{b}
f_U \left( \frac{v - a}{b} \right)\]</div>
<p>(The proof is <a class="reference internal" href="#statd-appendix"><span class="std std-ref">below</span></a>.  For a multidimensional version
see <a class="reference external" href="http://johnstachurski.net/edtc.html">EDTC</a>, theorem 8.1.3)</p>
<p>Taking <a class="reference internal" href="#equation-statd-dv">(20.6)</a> as given for the moment, we can
obtain the stochastic kernel <span class="math notranslate nohighlight">\(p\)</span> for <a class="reference internal" href="#equation-statd-srs">(20.3)</a> by recalling that
<span class="math notranslate nohighlight">\(p(x, \cdot)\)</span> is the conditional density of <span class="math notranslate nohighlight">\(X_{t+1}\)</span> given
<span class="math notranslate nohighlight">\(X_t = x\)</span>.</p>
<p>In the present case, this is equivalent to stating that <span class="math notranslate nohighlight">\(p(x, \cdot)\)</span> is the density of <span class="math notranslate nohighlight">\(Y := \mu(x) + \sigma(x) \, \xi_{t+1}\)</span> when <span class="math notranslate nohighlight">\(\xi_{t+1} \sim \phi\)</span>.</p>
<p>Hence, by <a class="reference internal" href="#equation-statd-dv">(20.6)</a>,</p>
<div class="math notranslate nohighlight" id="equation-statd-srssk">
<span class="eqno">(20.7)<a class="headerlink" href="#equation-statd-srssk" title="Permalink to this equation">¶</a></span>\[p(x, y)
= \frac{1}{\sigma(x)}
\phi \left( \frac{y - \mu(x)}{\sigma(x)} \right)\]</div>
<p>For example, the growth model in <a class="reference internal" href="#equation-statd-ss">(20.5)</a> has stochastic kernel</p>
<div class="math notranslate nohighlight" id="equation-statd-sssk">
<span class="eqno">(20.8)<a class="headerlink" href="#equation-statd-sssk" title="Permalink to this equation">¶</a></span>\[p(x, y)
= \frac{1}{sf(x)}
\phi \left( \frac{y - (1 - \delta) x}{s f(x)} \right)\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi\)</span> is the density of <span class="math notranslate nohighlight">\(A_{t+1}\)</span>.</p>
<p>(Regarding the state space <span class="math notranslate nohighlight">\(S\)</span> for this model, a natural choice is <span class="math notranslate nohighlight">\((0, \infty)\)</span> — in which case
<span class="math notranslate nohighlight">\(\sigma(x) = s f(x)\)</span> is strictly positive for all <span class="math notranslate nohighlight">\(s\)</span> as required)</p>
</div>
<div class="section" id="distribution-dynamics">
<h3><span class="section-number">20.2.3. </span>Distribution Dynamics<a class="headerlink" href="#distribution-dynamics" title="Permalink to this headline">¶</a></h3>
<p>In <a class="reference internal" href="finite_markov.html#mc-md"><span class="std std-ref">this section</span></a> of our lecture on <strong>finite</strong> Markov chains, we
asked the following question: If</p>
<ol class="simple">
<li><p><span class="math notranslate nohighlight">\(\{X_t\}\)</span> is a Markov chain with stochastic matrix <span class="math notranslate nohighlight">\(P\)</span></p></li>
<li><p>the distribution of <span class="math notranslate nohighlight">\(X_t\)</span> is known to be <span class="math notranslate nohighlight">\(\psi_t\)</span></p></li>
</ol>
<p>then what is the distribution of <span class="math notranslate nohighlight">\(X_{t+1}\)</span>?</p>
<p>Letting <span class="math notranslate nohighlight">\(\psi_{t+1}\)</span> denote the distribution of <span class="math notranslate nohighlight">\(X_{t+1}\)</span>, the
answer <a class="reference internal" href="finite_markov.html#mc-fdd"><span class="std std-ref">we gave</span></a> was that</p>
<div class="math notranslate nohighlight">
\[
\psi_{t+1}[j] = \sum_{i \in S} P[i,j] \psi_t[i]
\]</div>
<p>This intuitive equality states that the probability of being at <span class="math notranslate nohighlight">\(j\)</span>
tomorrow is the probability of visiting <span class="math notranslate nohighlight">\(i\)</span> today and then going on to
<span class="math notranslate nohighlight">\(j\)</span>, summed over all possible <span class="math notranslate nohighlight">\(i\)</span>.</p>
<p>In the density case, we just replace the sum with an integral and probability
mass functions with densities, yielding</p>
<div class="math notranslate nohighlight" id="equation-statd-fdd">
<span class="eqno">(20.9)<a class="headerlink" href="#equation-statd-fdd" title="Permalink to this equation">¶</a></span>\[\psi_{t+1}(y) = \int p(x,y) \psi_t(x) \, dx,
\qquad \forall y \in S\]</div>
<p>It is convenient to think of this updating process in terms of an operator.</p>
<p>(An operator is just a function, but the term is usually reserved for a function that sends functions into functions)</p>
<p>Let <span class="math notranslate nohighlight">\(\mathscr D\)</span> be the set of all densities on <span class="math notranslate nohighlight">\(S\)</span>, and let
<span class="math notranslate nohighlight">\(P\)</span> be the operator from <span class="math notranslate nohighlight">\(\mathscr D\)</span> to itself that takes density
<span class="math notranslate nohighlight">\(\psi\)</span> and sends it into new density <span class="math notranslate nohighlight">\(\psi P\)</span>, where the latter is
defined by</p>
<div class="math notranslate nohighlight" id="equation-def-dmo">
<span class="eqno">(20.10)<a class="headerlink" href="#equation-def-dmo" title="Permalink to this equation">¶</a></span>\[(\psi P)(y) = \int p(x,y) \psi(x) dx\]</div>
<p>This operator is usually called the <em>Markov operator</em> corresponding to <span class="math notranslate nohighlight">\(p\)</span></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unlike most operators, we write <span class="math notranslate nohighlight">\(P\)</span> to the right of its argument,
instead of to the left (i.e., <span class="math notranslate nohighlight">\(\psi P\)</span> instead of <span class="math notranslate nohighlight">\(P \psi\)</span>).
This is a common convention, with the intention being to maintain the
parallel with the finite case — see <a class="reference internal" href="finite_markov.html#mc-fddv"><span class="std std-ref">here</span></a>.</p>
</div>
<p>With this notation, we can write <a class="reference internal" href="#equation-statd-fdd">(20.9)</a> more succinctly as <span class="math notranslate nohighlight">\(\psi_{t+1}(y) = (\psi_t P)(y)\)</span> for all <span class="math notranslate nohighlight">\(y\)</span>, or, dropping the <span class="math notranslate nohighlight">\(y\)</span> and letting “<span class="math notranslate nohighlight">\(=\)</span>” indicate equality of functions,</p>
<div class="math notranslate nohighlight" id="equation-statd-p">
<span class="eqno">(20.11)<a class="headerlink" href="#equation-statd-p" title="Permalink to this equation">¶</a></span>\[\psi_{t+1} = \psi_t P\]</div>
<p>Equation <a class="reference internal" href="#equation-statd-p">(20.11)</a> tells us that if we specify a distribution for <span class="math notranslate nohighlight">\(\psi_0\)</span>, then the entire sequence
of future distributions can be obtained by iterating with <span class="math notranslate nohighlight">\(P\)</span>.</p>
<p>It’s interesting to note that <a class="reference internal" href="#equation-statd-p">(20.11)</a> is a deterministic difference equation.</p>
<p>Thus, by converting a stochastic difference equation such as
<a class="reference internal" href="#equation-statd-srs">(20.3)</a> into a stochastic kernel <span class="math notranslate nohighlight">\(p\)</span> and hence an operator
<span class="math notranslate nohighlight">\(P\)</span>, we convert a stochastic difference equation into a deterministic
one (albeit in a much higher dimensional space).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Some people might be aware that discrete Markov chains are in fact
a special case of the continuous Markov chains we have just described.  The reason is
that probability mass functions are densities with respect to
the <a class="reference external" href="https://en.wikipedia.org/wiki/Counting_measure">counting measure</a>.</p>
</div>
</div>
<div class="section" id="computation">
<h3><span class="section-number">20.2.4. </span>Computation<a class="headerlink" href="#computation" title="Permalink to this headline">¶</a></h3>
<p>To learn about the dynamics of a given process, it’s useful to compute and study the sequences of densities generated by the model.</p>
<p>One way to do this is to try to implement the iteration described by <a class="reference internal" href="#equation-def-dmo">(20.10)</a> and <a class="reference internal" href="#equation-statd-p">(20.11)</a> using numerical integration.</p>
<p>However, to produce <span class="math notranslate nohighlight">\(\psi P\)</span> from <span class="math notranslate nohighlight">\(\psi\)</span> via <a class="reference internal" href="#equation-def-dmo">(20.10)</a>, you
would need to integrate at every <span class="math notranslate nohighlight">\(y\)</span>, and there is a continuum of such
<span class="math notranslate nohighlight">\(y\)</span>.</p>
<p>Another possibility is to discretize the model, but this introduces errors of unknown size.</p>
<p>A nicer alternative in the present setting is to combine simulation with an elegant estimator called the <em>look ahead</em> estimator.</p>
<p>Let’s go over the ideas with reference to the growth model <a class="reference internal" href="#solow-swan"><span class="std std-ref">discussed above</span></a>, the dynamics of which we repeat here for convenience:</p>
<div class="math notranslate nohighlight" id="equation-statd-ss2">
<span class="eqno">(20.12)<a class="headerlink" href="#equation-statd-ss2" title="Permalink to this equation">¶</a></span>\[k_{t+1} = s  A_{t+1} f(k_t) + (1 - \delta) k_t\]</div>
<p>Our aim is to compute the sequence <span class="math notranslate nohighlight">\(\{ \psi_t \}\)</span> associated with this model and fixed initial condition <span class="math notranslate nohighlight">\(\psi_0\)</span>.</p>
<p>To approximate <span class="math notranslate nohighlight">\(\psi_t\)</span> by simulation, recall that, by definition, <span class="math notranslate nohighlight">\(\psi_t\)</span> is the density of <span class="math notranslate nohighlight">\(k_t\)</span> given <span class="math notranslate nohighlight">\(k_0 \sim \psi_0\)</span>.</p>
<p>If we wish to generate observations of this random variable,  all we need to do is</p>
<ol class="simple">
<li><p>draw <span class="math notranslate nohighlight">\(k_0\)</span> from the specified initial condition <span class="math notranslate nohighlight">\(\psi_0\)</span></p></li>
<li><p>draw the shocks <span class="math notranslate nohighlight">\(A_1, \ldots, A_t\)</span> from their specified density <span class="math notranslate nohighlight">\(\phi\)</span></p></li>
<li><p>compute <span class="math notranslate nohighlight">\(k_t\)</span> iteratively via <a class="reference internal" href="#equation-statd-ss2">(20.12)</a></p></li>
</ol>
<p>If we repeat this <span class="math notranslate nohighlight">\(n\)</span> times, we get <span class="math notranslate nohighlight">\(n\)</span> independent observations <span class="math notranslate nohighlight">\(k_t^1, \ldots, k_t^n\)</span>.</p>
<p>With these draws in hand, the next step is to generate some kind of representation of their distribution <span class="math notranslate nohighlight">\(\psi_t\)</span>.</p>
<p>A naive approach would be to use a histogram, or perhaps a <a class="reference external" href="https://en.wikipedia.org/wiki/Kernel_density_estimation">smoothed histogram</a> using  the <code class="docutils literal notranslate"><span class="pre">kde</span></code> function from <a class="reference external" href="https://github.com/JuliaStats/KernelDensity.jl">KernelDensity.jl</a>.</p>
<p>However, in the present setting there is a much better way to do this, based on the look-ahead estimator.</p>
<p>With this estimator, to construct an estimate of <span class="math notranslate nohighlight">\(\psi_t\)</span>, we
actually generate <span class="math notranslate nohighlight">\(n\)</span> observations of <span class="math notranslate nohighlight">\(k_{t-1}\)</span>, rather than <span class="math notranslate nohighlight">\(k_t\)</span>.</p>
<p>Now we take these <span class="math notranslate nohighlight">\(n\)</span> observations <span class="math notranslate nohighlight">\(k_{t-1}^1, \ldots,
k_{t-1}^n\)</span> and form the estimate</p>
<div class="math notranslate nohighlight" id="equation-statd-lae1">
<span class="eqno">(20.13)<a class="headerlink" href="#equation-statd-lae1" title="Permalink to this equation">¶</a></span>\[\psi_t^n(y) = \frac{1}{n} \sum_{i=1}^n p(k_{t-1}^i, y)\]</div>
<p>where <span class="math notranslate nohighlight">\(p\)</span> is the growth model stochastic kernel in <a class="reference internal" href="#equation-statd-sssk">(20.8)</a>.</p>
<p>What is the justification for this slightly surprising estimator?</p>
<p>The idea is that, by the strong <a class="reference internal" href="lln_clt.html#lln-ksl"><span class="std std-ref">law of large numbers</span></a>,</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{n} \sum_{i=1}^n p(k_{t-1}^i, y)
\to
\mathbb E p(k_{t-1}^i, y)
= \int p(x, y) \psi_{t-1}(x) \, dx
= \psi_t(y)
\]</div>
<p>with probability one as <span class="math notranslate nohighlight">\(n \to \infty\)</span>.</p>
<p>Here the first equality is by the definition of <span class="math notranslate nohighlight">\(\psi_{t-1}\)</span>, and the
second is by <a class="reference internal" href="#equation-statd-fdd">(20.9)</a>.</p>
<p>We have just shown that our estimator <span class="math notranslate nohighlight">\(\psi_t^n(y)\)</span> in <a class="reference internal" href="#equation-statd-lae1">(20.13)</a>
converges almost surely to <span class="math notranslate nohighlight">\(\psi_t(y)\)</span>, which is just what we want to compute.</p>
<p>In fact much stronger convergence results are true (see, for example, <a href=/_static/pdfs/ECTA6180.pdf download>this paper</a>).</p>
</div>
<div class="section" id="implementation">
<h3><span class="section-number">20.2.5. </span>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h3>
<p>A function which calls an <code class="docutils literal notranslate"><span class="pre">LAE</span></code> type for estimating densities by this technique can be found in <a class="reference external" href="https://github.com/QuantEcon/QuantEcon.jl/blob/master/src/lae.jl">lae.jl</a>.</p>
<p>This function returns the right-hand side of <a class="reference internal" href="#equation-statd-lae1">(20.13)</a> using</p>
<ul class="simple">
<li><p>an object of type <code class="docutils literal notranslate"><span class="pre">LAE</span></code> that stores the stochastic kernel and the observations</p></li>
<li><p>the value <span class="math notranslate nohighlight">\(y\)</span> as its second argument</p></li>
</ul>
<p>The function is vectorized, in the sense that if <code class="docutils literal notranslate"><span class="pre">psi</span></code> is such an instance and <code class="docutils literal notranslate"><span class="pre">y</span></code> is an array, then the call <code class="docutils literal notranslate"><span class="pre">psi(y)</span></code> acts elementwise.</p>
<p>(This is the reason that we reshaped <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> inside the type — to make vectorization work)</p>
</div>
<div class="section" id="example">
<h3><span class="section-number">20.2.6. </span>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<p>The following code is example of usage for the stochastic growth model <a class="reference internal" href="#solow-swan"><span class="std std-ref">described above</span></a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">Distributions</span><span class="p">,</span> <span class="n">StatsPlots</span><span class="p">,</span> <span class="n">Plots</span><span class="p">,</span> <span class="n">QuantEcon</span><span class="p">,</span> <span class="n">Random</span>
<span class="n">gr</span><span class="p">(</span><span class="n">fmt</span> <span class="o">=</span> <span class="ss">:png</span><span class="p">)</span>
<span class="n">Random</span><span class="o">.</span><span class="n">seed!</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="c"># For deterministic results.</span>

<span class="n">s</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">δ</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">a_σ</span> <span class="o">=</span> <span class="mf">0.4</span>                    <span class="c"># A = exp(B) where B ~ N(0, a_σ)</span>
<span class="n">α</span> <span class="o">=</span> <span class="mf">0.4</span>                      <span class="c"># We set f(k) = k**α</span>
<span class="n">ψ_0</span> <span class="o">=</span> <span class="n">Beta</span><span class="p">(</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">)</span>         <span class="c"># Initial distribution</span>
<span class="n">ϕ</span> <span class="o">=</span> <span class="n">LogNormal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">a_σ</span><span class="p">)</span>

<span class="k">function</span> <span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="c"># Stochastic kernel for the growth model with Cobb-Douglas production.</span>
    <span class="c"># Both x and y must be strictly positive.</span>

    <span class="n">d</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">x</span><span class="o">.^</span><span class="n">α</span>

    <span class="n">pdf_arg</span> <span class="o">=</span> <span class="n">clamp</span><span class="o">.</span><span class="p">((</span><span class="n">y</span> <span class="o">.-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">δ</span><span class="p">)</span> <span class="o">.*</span> <span class="n">x</span><span class="p">)</span> <span class="o">./</span> <span class="n">d</span><span class="p">,</span> <span class="n">eps</span><span class="p">(),</span> <span class="nb">Inf</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pdf</span><span class="o">.</span><span class="p">(</span><span class="n">ϕ</span><span class="p">,</span> <span class="n">pdf_arg</span><span class="p">)</span> <span class="o">./</span> <span class="n">d</span>
<span class="k">end</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">10000</span>  <span class="c"># Number of observations at each date t</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">30</span>     <span class="c"># Compute density of k_t at 1,...,T+1</span>

<span class="c"># Generate matrix s.t. t-th column is n observations of k_t</span>
<span class="n">k</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">rand!</span><span class="p">(</span><span class="n">ϕ</span><span class="p">,</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">T</span><span class="p">))</span>

<span class="c"># Draw first column from initial distribution</span>
<span class="n">k</span><span class="p">[</span><span class="o">:</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="n">ψ_0</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">./</span> <span class="mi">2</span>  <span class="c"># divide by 2 to match scale = 0.5 in py version</span>
<span class="k">for</span> <span class="n">t</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">T</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">k</span><span class="p">[</span><span class="o">:</span><span class="p">,</span> <span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">*</span><span class="n">A</span><span class="p">[</span><span class="o">:</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">.*</span> <span class="n">k</span><span class="p">[</span><span class="o">:</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span><span class="o">.^</span><span class="n">α</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">δ</span><span class="p">)</span> <span class="o">.*</span> <span class="n">k</span><span class="p">[</span><span class="o">:</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span>
<span class="k">end</span>

<span class="c"># Generate T instances of LAE using this data, one for each date t</span>
<span class="n">laes</span> <span class="o">=</span> <span class="p">[</span><span class="n">LAE</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">[</span><span class="o">:</span><span class="p">,</span> <span class="n">t</span><span class="p">])</span> <span class="k">for</span> <span class="n">t</span> <span class="k">in</span> <span class="n">T</span><span class="o">:-</span><span class="mi">1</span><span class="o">:</span><span class="mi">1</span><span class="p">]</span>

<span class="c"># Plot</span>
<span class="n">ygrid</span> <span class="o">=</span> <span class="n">range</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">200</span><span class="p">)</span>
<span class="n">laes_plot</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">colors</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">T</span>
    <span class="n">ψ</span> <span class="o">=</span> <span class="n">laes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">push!</span><span class="p">(</span><span class="n">laes_plot</span><span class="p">,</span> <span class="n">lae_est</span><span class="p">(</span><span class="n">ψ</span> <span class="p">,</span> <span class="n">ygrid</span><span class="p">))</span>
    <span class="n">push!</span><span class="p">(</span><span class="n">colors</span><span class="p">,</span>  <span class="n">RGBA</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">T</span><span class="p">))</span>
<span class="k">end</span>
<span class="n">plot</span><span class="p">(</span><span class="n">ygrid</span><span class="p">,</span> <span class="n">laes_plot</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">colors</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">length</span><span class="p">(</span><span class="n">colors</span><span class="p">)),</span> <span class="n">lw</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
     <span class="n">xlabel</span> <span class="o">=</span> <span class="s">&quot;capital&quot;</span><span class="p">,</span> <span class="n">legend</span> <span class="o">=</span> <span class="ss">:none</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="s">&quot;Density of k_1 (lighter) to k_T (darker) for T=</span><span class="si">$T</span><span class="s">&quot;</span>
<span class="n">plot!</span><span class="p">(</span><span class="n">title</span> <span class="o">=</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/stationary_densities_4_0.png" src="../_images/stationary_densities_4_0.png" />
</div>
</div>
<p>The figure shows part of the density sequence <span class="math notranslate nohighlight">\(\{\psi_t\}\)</span>, with each
density computed via the look ahead estimator.</p>
<p>Notice that the sequence of densities shown in the figure seems to be
converging — more on this in just a moment.</p>
<p>Another quick comment is that each of these distributions could be interpreted
as a cross sectional distribution (recall <a class="reference internal" href="finite_markov.html#mc-eg1-1"><span class="std std-ref">this discussion</span></a>).</p>
</div>
</div>
<div class="section" id="beyond-densities">
<h2><a class="toc-backref" href="#id14"><span class="section-number">20.3. </span>Beyond Densities</a><a class="headerlink" href="#beyond-densities" title="Permalink to this headline">¶</a></h2>
<p>Up until now, we have focused exclusively on continuous state Markov chains
where all conditional distributions <span class="math notranslate nohighlight">\(p(x, \cdot)\)</span> are densities.</p>
<p>As discussed above, not all distributions can be represented as densities.</p>
<p>If the conditional distribution of <span class="math notranslate nohighlight">\(X_{t+1}\)</span> given <span class="math notranslate nohighlight">\(X_t = x\)</span>
<strong>cannot</strong> be represented as a density for some <span class="math notranslate nohighlight">\(x \in S\)</span>, then we need a slightly
different theory.</p>
<p>The ultimate option is to switch from densities to <a class="reference external" href="https://en.wikipedia.org/wiki/Probability_measure">probability measures</a>, but not all readers will
be familiar with measure theory.</p>
<p>We can, however, construct a fairly general theory using distribution functions.</p>
<div class="section" id="example-and-definitions">
<h3><span class="section-number">20.3.1. </span>Example and Definitions<a class="headerlink" href="#example-and-definitions" title="Permalink to this headline">¶</a></h3>
<p>To illustrate the issues, recall that Hopenhayn and Rogerson <span id="id3">[<a class="reference internal" href="../zreferences.html#id88">HR93</a>]</span> study a model of firm dynamics where individual firm productivity follows the exogenous process</p>
<div class="math notranslate nohighlight">
\[
X_{t+1} = a + \rho X_t + \xi_{t+1},
\quad \text{where} \quad
\{ \xi_t \} \stackrel {\textrm{ IID }} {\sim} N(0, \sigma^2)
\]</div>
<p>As is, this fits into the density case we treated above.</p>
<p>However, the authors wanted this process to take values in <span class="math notranslate nohighlight">\([0, 1]\)</span>, so they added boundaries at the end points 0 and 1.</p>
<p>One way to write this is</p>
<div class="math notranslate nohighlight">
\[
X_{t+1} = h(a + \rho X_t + \xi_{t+1})
\quad \text{where} \quad
h(x) := x \, \mathbf 1\{0 \leq x \leq 1\} + \mathbf 1 \{ x &gt; 1\}
\]</div>
<p>If you think about it, you will see that for any given <span class="math notranslate nohighlight">\(x \in [0, 1]\)</span>,
the conditional distribution of <span class="math notranslate nohighlight">\(X_{t+1}\)</span> given <span class="math notranslate nohighlight">\(X_t = x\)</span>
puts positive probability mass on 0 and 1.</p>
<p>Hence it cannot be represented as a density.</p>
<p>What we can do instead is use cumulative distribution functions (cdfs).</p>
<p>To this end, set</p>
<div class="math notranslate nohighlight">
\[
G(x, y) := \mathbb P \{ h(a + \rho x + \xi_{t+1}) \leq y \}
\qquad (0 \leq x, y \leq 1)
\]</div>
<p>This family of cdfs <span class="math notranslate nohighlight">\(G(x, \cdot)\)</span> plays a role analogous to the stochastic kernel in the density case.</p>
<p>The distribution dynamics in <a class="reference internal" href="#equation-statd-fdd">(20.9)</a> are then replaced by</p>
<div class="math notranslate nohighlight" id="equation-statd-fddc">
<span class="eqno">(20.14)<a class="headerlink" href="#equation-statd-fddc" title="Permalink to this equation">¶</a></span>\[F_{t+1}(y) = \int G(x,y) F_t(dx)\]</div>
<p>Here <span class="math notranslate nohighlight">\(F_t\)</span> and <span class="math notranslate nohighlight">\(F_{t+1}\)</span> are cdfs representing the distribution of the current state and next period state.</p>
<p>The intuition behind <a class="reference internal" href="#equation-statd-fddc">(20.14)</a> is essentially the same as for <a class="reference internal" href="#equation-statd-fdd">(20.9)</a>.</p>
</div>
<div class="section" id="id4">
<h3><span class="section-number">20.3.2. </span>Computation<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>If you wish to compute these cdfs, you cannot use the look-ahead estimator as before.</p>
<p>Indeed, you should not use any density estimator, since the objects you are
estimating/computing are not densities.</p>
<p>One good option is simulation as before, combined with the <a class="reference external" href="https://en.wikipedia.org/wiki/Empirical_distribution_function">empirical distribution function</a>.</p>
</div>
</div>
<div class="section" id="stability">
<h2><a class="toc-backref" href="#id15"><span class="section-number">20.4. </span>Stability</a><a class="headerlink" href="#stability" title="Permalink to this headline">¶</a></h2>
<p>In our <a class="reference internal" href="finite_markov.html"><span class="doc">lecture</span></a> on finite Markov chains we also studied stationarity, stability and ergodicity.</p>
<p>Here we will cover the same topics for the continuous case.</p>
<p>We will, however, treat only the density case (as in <a class="reference internal" href="#statd-density-case"><span class="std std-ref">this section</span></a>), where the stochastic kernel is a family of densities.</p>
<p>The general case is relatively similar — references are given below.</p>
<div class="section" id="theoretical-results">
<h3><span class="section-number">20.4.1. </span>Theoretical Results<a class="headerlink" href="#theoretical-results" title="Permalink to this headline">¶</a></h3>
<p>Analogous to <a class="reference internal" href="finite_markov.html#mc-stat-dd"><span class="std std-ref">the finite case</span></a>, given a stochastic kernel <span class="math notranslate nohighlight">\(p\)</span> and corresponding Markov operator as
defined in <a class="reference internal" href="#equation-def-dmo">(20.10)</a>, a density <span class="math notranslate nohighlight">\(\psi^*\)</span> on <span class="math notranslate nohighlight">\(S\)</span> is called
<em>stationary</em> for <span class="math notranslate nohighlight">\(P\)</span> if it is a fixed point of the operator <span class="math notranslate nohighlight">\(P\)</span>.</p>
<p>In other words,</p>
<div class="math notranslate nohighlight" id="equation-statd-dsd">
<span class="eqno">(20.15)<a class="headerlink" href="#equation-statd-dsd" title="Permalink to this equation">¶</a></span>\[\psi^*(y) = \int p(x,y) \psi^*(x) \, dx,
\qquad \forall y \in S\]</div>
<p>As with the finite case, if <span class="math notranslate nohighlight">\(\psi^*\)</span> is stationary for <span class="math notranslate nohighlight">\(P\)</span>, and
the distribution of <span class="math notranslate nohighlight">\(X_0\)</span> is <span class="math notranslate nohighlight">\(\psi^*\)</span>, then, in view of
<a class="reference internal" href="#equation-statd-p">(20.11)</a>, <span class="math notranslate nohighlight">\(X_t\)</span> will have this same distribution for all <span class="math notranslate nohighlight">\(t\)</span>.</p>
<p>Hence <span class="math notranslate nohighlight">\(\psi^*\)</span> is the stochastic equivalent of a steady state.</p>
<p>In the finite case, we learned that at least one stationary distribution exists, although there may be many.</p>
<p>When the state space is infinite, the situation is more complicated.</p>
<p>Even existence can fail very easily.</p>
<p>For example, the random walk model has no stationary density (see, e.g., <a class="reference external" href="http://johnstachurski.net/edtc.html">EDTC</a>, p. 210).</p>
<p>However, there are well-known conditions under which a stationary density <span class="math notranslate nohighlight">\(\psi^*\)</span> exists.</p>
<p>With additional conditions, we can also get a unique stationary density (<span class="math notranslate nohighlight">\(\psi \in \mathscr D \text{ and } \psi = \psi P \implies \psi = \psi^*\)</span>),  and also global convergence in the sense that</p>
<div class="math notranslate nohighlight" id="equation-statd-dca">
<span class="eqno">(20.16)<a class="headerlink" href="#equation-statd-dca" title="Permalink to this equation">¶</a></span>\[\forall \, \psi \in \mathscr D, \quad \psi P^t \to \psi^*
    \quad \text{as} \quad t \to \infty\]</div>
<p>This combination of existence, uniqueness and global convergence in the sense
of <a class="reference internal" href="#equation-statd-dca">(20.16)</a> is often referred to as <em>global stability</em>.</p>
<p>Under very similar conditions, we get <em>ergodicity</em>, which means that</p>
<div class="math notranslate nohighlight" id="equation-statd-lln">
<span class="eqno">(20.17)<a class="headerlink" href="#equation-statd-lln" title="Permalink to this equation">¶</a></span>\[\frac{1}{n} \sum_{t = 1}^n h(X_t)  \to \int h(x) \psi^*(x) dx
    \quad \text{as } n \to \infty\]</div>
<p>for any (<a class="reference external" href="https://en.wikipedia.org/wiki/Measurable_function">measurable</a>) function <span class="math notranslate nohighlight">\(h \colon S \to \mathbb R\)</span>  such that the right-hand side is finite.</p>
<p>Note that the convergence in <a class="reference internal" href="#equation-statd-lln">(20.17)</a> does not depend on the distribution (or value) of <span class="math notranslate nohighlight">\(X_0\)</span>.</p>
<p>This is actually very important for simulation — it means we can learn about <span class="math notranslate nohighlight">\(\psi^*\)</span> (i.e., approximate the right hand side of <a class="reference internal" href="#equation-statd-lln">(20.17)</a> via the left hand side) without requiring any special knowledge about what to do with <span class="math notranslate nohighlight">\(X_0\)</span>.</p>
<p>So what are these conditions we require to get global stability and ergodicity?</p>
<p>In essence, it must be the case that</p>
<ol class="simple">
<li><p>Probability mass does not drift off to the “edges” of the state space</p></li>
<li><p>Sufficient “mixing” obtains</p></li>
</ol>
<p>For one such set of conditions see theorem 8.2.14 of <a class="reference external" href="http://johnstachurski.net/edtc.html">EDTC</a>.</p>
<p>In addition</p>
<ul class="simple">
<li><p><span id="id5">[<a class="reference internal" href="../zreferences.html#id130">SLP89</a>]</span>  contains a classic (but slightly outdated) treatment of these topics.</p></li>
<li><p>From the mathematical literature, <span id="id6">[<a class="reference internal" href="../zreferences.html#id98">LM94</a>]</span>  and <span id="id7">[<a class="reference internal" href="../zreferences.html#id109">MT09</a>]</span> give outstanding in depth treatments.</p></li>
<li><p>Section 8.1.2 of <a class="reference external" href="http://johnstachurski.net/edtc.html">EDTC</a> provides detailed intuition, and section 8.3 gives additional references.</p></li>
<li><p><a class="reference external" href="http://johnstachurski.net/edtc.html">EDTC</a>, section 11.3.4
provides a specific treatment for the growth model we considered in this
lecture.</p></li>
</ul>
</div>
<div class="section" id="an-example-of-stability">
<h3><span class="section-number">20.4.2. </span>An Example of Stability<a class="headerlink" href="#an-example-of-stability" title="Permalink to this headline">¶</a></h3>
<p>As stated above, the <a class="reference internal" href="#solow-swan"><span class="std std-ref">growth model treated here</span></a> is stable under mild conditions
on the primitives.</p>
<ul class="simple">
<li><p>See <a class="reference external" href="http://johnstachurski.net/edtc.html">EDTC</a>, section 11.3.4 for more details.</p></li>
</ul>
<p>We can see this stability in action — in particular, the convergence in <a class="reference internal" href="#equation-statd-dca">(20.16)</a> — by simulating the path of densities from various initial conditions.</p>
<p>Here is such a figure</p>
<div class="figure align-default" id="statd-egs">
<a class="reference internal image-reference" href="../_images/solution_statd_ex2.png"><img alt="../_images/solution_statd_ex2.png" src="../_images/solution_statd_ex2.png" style="width: 85%;" /></a>
</div>
<p>All sequences are converging towards the same limit, regardless of their initial condition.</p>
<p>The details regarding initial conditions and so on are given in <a class="reference internal" href="#statd-ex2"><span class="std std-ref">this exercise</span></a>, where you are asked to replicate the figure.</p>
</div>
<div class="section" id="computing-stationary-densities">
<h3><span class="section-number">20.4.3. </span>Computing Stationary Densities<a class="headerlink" href="#computing-stationary-densities" title="Permalink to this headline">¶</a></h3>
<p>In the preceding figure, each sequence of densities is converging towards the unique stationary density <span class="math notranslate nohighlight">\(\psi^*\)</span>.</p>
<p>Even from this figure we can get a fair idea what <span class="math notranslate nohighlight">\(\psi^*\)</span> looks like, and where its mass is located.</p>
<p>However, there is a much more direct way to estimate the stationary density,
and it involves only a slight modification of the look ahead estimator.</p>
<p>Let’s say that we have a model of the form <a class="reference internal" href="#equation-statd-srs">(20.3)</a> that is stable and
ergodic.</p>
<p>Let <span class="math notranslate nohighlight">\(p\)</span> be the corresponding stochastic kernel, as given in <a class="reference internal" href="#equation-statd-srssk">(20.7)</a>.</p>
<p>To approximate the stationary density <span class="math notranslate nohighlight">\(\psi^*\)</span>, we can simply generate a
long time series <span class="math notranslate nohighlight">\(X_0, X_1, \ldots, X_n\)</span> and estimate <span class="math notranslate nohighlight">\(\psi^*\)</span> via</p>
<div class="math notranslate nohighlight" id="equation-statd-lae2">
<span class="eqno">(20.18)<a class="headerlink" href="#equation-statd-lae2" title="Permalink to this equation">¶</a></span>\[\psi_n^*(y) = \frac{1}{n} \sum_{t=1}^n p(X_t, y)\]</div>
<p>This is essentially the same as the look ahead estimator <a class="reference internal" href="#equation-statd-lae1">(20.13)</a>,
except that now the observations we generate are a single time series, rather
than a cross section.</p>
<p>The justification for <a class="reference internal" href="#equation-statd-lae2">(20.18)</a> is that, with probability one as <span class="math notranslate nohighlight">\(n \to \infty\)</span>,</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{n} \sum_{t=1}^n p(X_t, y)
\to
\int p(x, y) \psi^*(x) \, dx
= \psi^*(y)
\]</div>
<p>where the convergence is by <a class="reference internal" href="#equation-statd-lln">(20.17)</a> and the equality on the right is by
<a class="reference internal" href="#equation-statd-dsd">(20.15)</a>.</p>
<p>The right hand side is exactly what we want to compute.</p>
<p>On top of this asymptotic result, it turns out that the rate of convergence
for the look ahead estimator is very good.</p>
<p>The first exercise helps illustrate this point.</p>
</div>
</div>
<div class="section" id="exercises">
<h2><a class="toc-backref" href="#id16"><span class="section-number">20.5. </span>Exercises</a><a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<div class="section" id="exercise-1">
<span id="statd-ex1"></span><h3><span class="section-number">20.5.1. </span>Exercise 1<a class="headerlink" href="#exercise-1" title="Permalink to this headline">¶</a></h3>
<p>Consider the simple threshold autoregressive model</p>
<div class="math notranslate nohighlight" id="equation-statd-tar">
<span class="eqno">(20.19)<a class="headerlink" href="#equation-statd-tar" title="Permalink to this equation">¶</a></span>\[X_{t+1} = \theta |X_t| + (1- \theta^2)^{1/2} \xi_{t+1}
\qquad \text{where} \quad
\{ \xi_t \} \stackrel {\textrm{ IID }} {\sim} N(0, 1)\]</div>
<p>This is one of those rare nonlinear stochastic models where an analytical
expression for the stationary density is available.</p>
<p>In particular, provided that <span class="math notranslate nohighlight">\(|\theta| &lt; 1\)</span>, there is a unique
stationary density <span class="math notranslate nohighlight">\(\psi^*\)</span> given by</p>
<div class="math notranslate nohighlight" id="equation-statd-tar-ts">
<span class="eqno">(20.20)<a class="headerlink" href="#equation-statd-tar-ts" title="Permalink to this equation">¶</a></span>\[\psi^*(y) = 2 \, \phi(y) \, \Phi
\left[
    \frac{\theta y}{(1 - \theta^2)^{1/2}}
\right]\]</div>
<p>Here <span class="math notranslate nohighlight">\(\phi\)</span> is the standard normal density and <span class="math notranslate nohighlight">\(\Phi\)</span> is the standard normal cdf.</p>
<p>As an exercise, compute the look ahead estimate of <span class="math notranslate nohighlight">\(\psi^*\)</span>, as defined
in <a class="reference internal" href="#equation-statd-lae2">(20.18)</a>, and compare it with <span class="math notranslate nohighlight">\(\psi^*\)</span>  in <a class="reference internal" href="#equation-statd-tar-ts">(20.20)</a> to see whether they
are indeed close for large <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>In doing so, set <span class="math notranslate nohighlight">\(\theta = 0.8\)</span> and <span class="math notranslate nohighlight">\(n = 500\)</span>.</p>
<p>The next figure shows the result of such a computation</p>
<div class="figure align-default">
<a class="reference internal image-reference" href="../_images/solution_statd_ex1.png"><img alt="../_images/solution_statd_ex1.png" src="../_images/solution_statd_ex1.png" style="width: 75%;" /></a>
</div>
<p>The additional density (black line) is a <a class="reference external" href="https://en.wikipedia.org/wiki/Kernel_density_estimation">nonparametric kernel density estimate</a>, added to the solution for illustration.</p>
<p>(You can try to replicate it before looking at the solution if you want to)</p>
<p>As you can see, the look ahead estimator is a much tighter fit than the kernel
density estimator.</p>
<p>If you repeat the simulation you will see that this is consistently the case.</p>
</div>
<div class="section" id="exercise-2">
<span id="statd-ex2"></span><h3><span class="section-number">20.5.2. </span>Exercise 2<a class="headerlink" href="#exercise-2" title="Permalink to this headline">¶</a></h3>
<p>Replicate the figure on global convergence <a class="reference internal" href="#statd-egs"><span class="std std-ref">shown above</span></a>.</p>
<p>The densities come from the stochastic growth model treated <a class="reference internal" href="#solow-swan"><span class="std std-ref">at the start of the lecture</span></a>.</p>
<p>Begin with the code found in <a class="reference external" href="https://github.com/QuantEcon/QuantEcon.lectures.code/blob/master/stationary_densities/stochasticgrowth.jl">stochasticgrowth.py</a>.</p>
<p>Use the same parameters.</p>
<p>For the four initial distributions, use the beta distribution and shift the random draws as shown below</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">ψ_0</span> <span class="o">=</span> <span class="n">Beta</span><span class="p">(</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">)</span>  <span class="c"># Initial distribution</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="c"># .... more setup</span>

<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="mi">4</span>
    <span class="c"># .... some code</span>
    <span class="n">rand_draws</span> <span class="o">=</span> <span class="p">(</span><span class="n">rand</span><span class="p">(</span><span class="n">ψ_0</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">.+</span> <span class="mf">2.5</span><span class="n">i</span><span class="p">)</span> <span class="o">./</span> <span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="section" id="exercise-3">
<span id="statd-ex3"></span><h3><span class="section-number">20.5.3. </span>Exercise 3<a class="headerlink" href="#exercise-3" title="Permalink to this headline">¶</a></h3>
<p>A common way to compare distributions visually is with <a class="reference external" href="https://en.wikipedia.org/wiki/Box_plot">boxplots</a>.</p>
<p>To illustrate, let’s generate three artificial data sets and compare them with a boxplot</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="mi">500</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">randn</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>        <span class="c"># N(0, 1)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">exp</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>         <span class="c"># Map x to lognormal</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">randn</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">.+</span> <span class="mf">2.0</span>  <span class="c"># N(2, 1)</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">randn</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">.+</span> <span class="mf">4.0</span>  <span class="c"># N(4, 1)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">vcat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;X&quot;</span> <span class="s">&quot;Y&quot;</span> <span class="s">&quot;Z&quot;</span><span class="p">]</span>
<span class="n">xlabels</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">repeat</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="mi">3</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">boxplot</span><span class="p">(</span><span class="n">xlabels</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">ylims</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">14</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/stationary_densities_8_0.png" src="../_images/stationary_densities_8_0.png" />
</div>
</div>
<p>The three data sets are</p>
<div class="math notranslate nohighlight">
\[
\{ X_1, \ldots, X_n \} \sim LN(0, 1), \;\;
\{ Y_1, \ldots, Y_n \} \sim N(2, 1), \;\;
\text{ and } \;
\{ Z_1, \ldots, Z_n \} \sim N(4, 1), \;
\]</div>
<p>The figure looks as follows.</p>
<p>Each data set is represented by a box, where the top and bottom of the box are the third and first quartiles of the data, and the red line in the center is the median.</p>
<p>The boxes give some indication as to</p>
<ul class="simple">
<li><p>the location of probability mass for each sample</p></li>
<li><p>whether the distribution is right-skewed (as is the lognormal distribution), etc</p></li>
</ul>
<p>Now let’s put these ideas to use in a simulation.</p>
<p>Consider the threshold autoregressive model in <a class="reference internal" href="#equation-statd-tar">(20.19)</a>.</p>
<p>We know that the distribution of <span class="math notranslate nohighlight">\(X_t\)</span> will converge to <a class="reference internal" href="#equation-statd-tar-ts">(20.20)</a> whenever <span class="math notranslate nohighlight">\(|\theta| &lt; 1\)</span>.</p>
<p>Let’s observe this convergence from different initial conditions using
boxplots.</p>
<p>In particular, the exercise is to generate J boxplot figures, one for each initial condition <span class="math notranslate nohighlight">\(X_0\)</span> in</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">initial_conditions</span> <span class="o">=</span> <span class="n">range</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="n">J</span><span class="p">)</span>
</pre></div>
</div>
<p>For each <span class="math notranslate nohighlight">\(X_0\)</span> in this set,</p>
<ol class="simple">
<li><p>Generate <span class="math notranslate nohighlight">\(k\)</span> time series of length <span class="math notranslate nohighlight">\(n\)</span>, each starting at <span class="math notranslate nohighlight">\(X_0\)</span> and obeying <a class="reference internal" href="#equation-statd-tar">(20.19)</a>.</p></li>
<li><p>Create a boxplot representing <span class="math notranslate nohighlight">\(n\)</span> distributions, where the <span class="math notranslate nohighlight">\(t\)</span>-th distribution shows the <span class="math notranslate nohighlight">\(k\)</span> observations of <span class="math notranslate nohighlight">\(X_t\)</span>.</p></li>
</ol>
<p>Use <span class="math notranslate nohighlight">\(\theta = 0.9, n = 20, k = 5000, J = 8\)</span>.</p>
</div>
</div>
<div class="section" id="solutions">
<h2><a class="toc-backref" href="#id17"><span class="section-number">20.6. </span>Solutions</a><a class="headerlink" href="#solutions" title="Permalink to this headline">¶</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">KernelDensity</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id8">
<h3><span class="section-number">20.6.1. </span>Exercise 1<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>Look ahead estimation of a TAR stationary density, where the TAR model
is</p>
<div class="math notranslate nohighlight">
\[
X_{t+1} = \theta |X_t| + (1 - \theta^2)^{1/2} \xi_{t+1}
\]</div>
<p>and <span class="math notranslate nohighlight">\(\xi_t \sim N(0,1)\)</span>. Try running at n = 10, 100, 1000, 10000
to get an idea of the speed of convergence.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">ϕ</span> <span class="o">=</span> <span class="n">Normal</span><span class="p">()</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">500</span>
<span class="n">θ</span> <span class="o">=</span> <span class="mf">0.8</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">θ</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
<span class="n">δ</span> <span class="o">=</span> <span class="n">θ</span> <span class="o">/</span> <span class="n">d</span>

<span class="c"># true density of TAR model</span>
<span class="n">ψ_star</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">.*</span> <span class="n">pdf</span><span class="o">.</span><span class="p">(</span><span class="n">ϕ</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">.*</span> <span class="n">cdf</span><span class="o">.</span><span class="p">(</span><span class="n">ϕ</span><span class="p">,</span> <span class="n">δ</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>

<span class="c"># Stochastic kernel for the TAR model.</span>
<span class="n">p_TAR</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">pdf</span><span class="o">.</span><span class="p">(</span><span class="n">ϕ</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span> <span class="o">.-</span> <span class="n">θ</span> <span class="o">.*</span> <span class="n">abs</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">./</span> <span class="n">d</span><span class="p">)</span> <span class="o">./</span> <span class="n">d</span>

<span class="n">Z</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="n">ϕ</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="k">for</span> <span class="n">t</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">X</span><span class="p">[</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">θ</span> <span class="o">*</span> <span class="n">abs</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">t</span><span class="p">])</span> <span class="o">+</span> <span class="n">d</span> <span class="o">*</span> <span class="n">Z</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">ψ_est</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="n">lae_est</span><span class="p">(</span><span class="n">LAE</span><span class="p">(</span><span class="n">p_TAR</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">a</span><span class="p">)</span>
<span class="n">k_est</span> <span class="o">=</span> <span class="n">kde</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="n">ys</span> <span class="o">=</span> <span class="n">range</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">200</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ψ_star</span><span class="p">(</span><span class="n">ys</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="ss">:blue</span><span class="p">,</span> <span class="n">lw</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.6</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s">&quot;true&quot;</span><span class="p">)</span>
<span class="n">plot!</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ψ_est</span><span class="p">(</span><span class="n">ys</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="ss">:green</span><span class="p">,</span> <span class="n">lw</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.6</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s">&quot;look ahead estimate&quot;</span><span class="p">)</span>
<span class="n">plot!</span><span class="p">(</span><span class="n">k_est</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">k_est</span><span class="o">.</span><span class="n">density</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="ss">:black</span><span class="p">,</span> <span class="n">lw</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.6</span><span class="p">,</span>
      <span class="n">label</span> <span class="o">=</span> <span class="s">&quot;kernel based estimate&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/stationary_densities_13_0.png" src="../_images/stationary_densities_13_0.png" />
</div>
</div>
</div>
<div class="section" id="id9">
<h3><span class="section-number">20.6.2. </span>Exercise 2<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p>Here’s one program that does the job.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">δ</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">a_σ</span> <span class="o">=</span> <span class="mf">0.4</span>  <span class="c"># A = exp(B) where B ~ N(0, a_σ)</span>
<span class="n">α</span> <span class="o">=</span> <span class="mf">0.4</span>    <span class="c"># We set f(k) = k**α</span>
<span class="n">ψ_0</span> <span class="o">=</span> <span class="n">Beta</span><span class="p">(</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">)</span>  <span class="c"># Initial distribution</span>
<span class="n">ϕ</span> <span class="o">=</span> <span class="n">LogNormal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">a_σ</span><span class="p">)</span>

<span class="k">function</span> <span class="n">p_growth</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="c"># Stochastic kernel for the growth model with Cobb-Douglas production.</span>
    <span class="c"># Both x and y must be strictly positive.</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">x</span><span class="o">.^</span><span class="n">α</span>

    <span class="n">pdf_arg</span> <span class="o">=</span> <span class="n">clamp</span><span class="o">.</span><span class="p">((</span><span class="n">y</span> <span class="o">.-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">δ</span><span class="p">)</span> <span class="o">.*</span> <span class="n">x</span><span class="p">)</span> <span class="o">./</span> <span class="n">d</span><span class="p">,</span> <span class="n">eps</span><span class="p">(),</span> <span class="nb">Inf</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pdf</span><span class="o">.</span><span class="p">(</span><span class="n">ϕ</span><span class="p">,</span> <span class="n">pdf_arg</span><span class="p">)</span> <span class="o">./</span> <span class="n">d</span>
<span class="k">end</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">1000</span>  <span class="c"># Number of observations at each date t</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">40</span>    <span class="c"># Compute density of k_t at 1,...,T+1</span>

<span class="n">xmax</span> <span class="o">=</span> <span class="mf">6.5</span>
<span class="n">ygrid</span> <span class="o">=</span> <span class="n">range</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">150</span><span class="p">)</span>
<span class="n">laes_plot</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">ygrid</span><span class="p">),</span> <span class="mi">4</span><span class="n">T</span><span class="p">)</span>
<span class="n">colors</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="mi">4</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">rand!</span><span class="p">(</span><span class="n">ϕ</span><span class="p">,</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">T</span><span class="p">))</span>

    <span class="c"># Draw first column from initial distribution</span>
    <span class="c"># match scale = 0.5 and loc = 2i in julia version</span>
    <span class="n">k</span><span class="p">[</span><span class="o">:</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rand</span><span class="p">(</span><span class="n">ψ_0</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">.+</span> <span class="mf">2.5</span><span class="n">i</span><span class="p">)</span> <span class="o">./</span> <span class="mi">2</span>
    <span class="k">for</span> <span class="n">t</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">T</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">k</span><span class="p">[</span><span class="o">:</span><span class="p">,</span> <span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="o">:</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">.*</span> <span class="n">k</span><span class="p">[</span><span class="o">:</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span><span class="o">.^</span><span class="n">α</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">δ</span><span class="p">)</span> <span class="o">.*</span> <span class="n">k</span><span class="p">[</span><span class="o">:</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span>
    <span class="k">end</span>

    <span class="c"># Generate T instances of LAE using this data, one for each date t</span>
    <span class="n">laes</span> <span class="o">=</span> <span class="p">[</span><span class="n">LAE</span><span class="p">(</span><span class="n">p_growth</span><span class="p">,</span> <span class="n">k</span><span class="p">[</span><span class="o">:</span><span class="p">,</span> <span class="n">t</span><span class="p">])</span> <span class="k">for</span> <span class="n">t</span> <span class="k">in</span> <span class="n">T</span><span class="o">:-</span><span class="mi">1</span><span class="o">:</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">i</span>
    <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">T</span>
        <span class="n">ψ</span> <span class="o">=</span> <span class="n">laes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">laes_plot</span><span class="p">[</span><span class="o">:</span><span class="p">,</span> <span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">lae_est</span><span class="p">(</span><span class="n">ψ</span><span class="p">,</span> <span class="n">ygrid</span><span class="p">)</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">4</span>
        <span class="n">push!</span><span class="p">(</span><span class="n">colors</span><span class="p">,</span>  <span class="n">RGBA</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">T</span><span class="p">))</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="c">#colors = reshape(reshape(colors, T, 4)&#39;, 4*T, 1)</span>
<span class="n">colors</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">colors</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">length</span><span class="p">(</span><span class="n">colors</span><span class="p">))</span>
<span class="n">plot</span><span class="p">(</span><span class="n">ygrid</span><span class="p">,</span> <span class="n">laes_plot</span><span class="p">,</span> <span class="n">layout</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">color</span> <span class="o">=</span> <span class="n">colors</span><span class="p">,</span>
     <span class="n">legend</span> <span class="o">=</span> <span class="ss">:none</span><span class="p">,</span> <span class="n">xlabel</span> <span class="o">=</span> <span class="s">&quot;capital&quot;</span><span class="p">,</span> <span class="n">xlims</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">xmax</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/stationary_densities_17_0.png" src="../_images/stationary_densities_17_0.png" />
</div>
</div>
</div>
<div class="section" id="id10">
<h3><span class="section-number">20.6.3. </span>Exercise 3<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>Here’s a possible solution.</p>
<p>Note the way we use vectorized code to simulate the <span class="math notranslate nohighlight">\(k\)</span> time
series for one boxplot all at once.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">5000</span>
<span class="n">J</span> <span class="o">=</span> <span class="mi">6</span>

<span class="n">θ</span> <span class="o">=</span> <span class="mf">0.9</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">θ</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
<span class="n">δ</span> <span class="o">=</span> <span class="n">θ</span> <span class="o">/</span> <span class="n">d</span>

<span class="n">initial_conditions</span> <span class="o">=</span> <span class="n">range</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="n">J</span><span class="p">)</span>

<span class="n">Z</span> <span class="o">=</span> <span class="n">randn</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>
<span class="n">titles</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">x_labels</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">J</span>
    <span class="n">title</span> <span class="o">=</span> <span class="s">&quot;time series from t = </span><span class="si">$</span><span class="p">(</span><span class="n">initial_conditions</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="s">&quot;</span>
    <span class="n">push!</span><span class="p">(</span><span class="n">titles</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">X</span><span class="p">[</span><span class="o">:</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">.=</span> <span class="n">initial_conditions</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">vcat</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">ones</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">t</span> <span class="k">in</span> <span class="mi">2</span><span class="o">:</span><span class="n">n</span>
        <span class="n">X</span><span class="p">[</span><span class="o">:</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">θ</span> <span class="o">.*</span> <span class="n">abs</span><span class="o">.</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="o">:</span><span class="p">,</span> <span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">.+</span> <span class="n">d</span> <span class="o">.*</span> <span class="n">Z</span><span class="p">[</span><span class="o">:</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">vcat</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">t</span><span class="o">*</span><span class="n">ones</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">end</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">n</span><span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">push!</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
    <span class="n">push!</span><span class="p">(</span><span class="n">x_labels</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">plots</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">J</span>
    <span class="n">push!</span><span class="p">(</span><span class="n">plots</span><span class="p">,</span> <span class="n">boxplot</span><span class="p">(</span><span class="n">vec</span><span class="p">(</span><span class="n">x_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">vec</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">title</span> <span class="o">=</span> <span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
<span class="k">end</span>
<span class="n">plot</span><span class="p">(</span><span class="n">plots</span><span class="o">...</span><span class="p">,</span> <span class="n">layout</span> <span class="o">=</span> <span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">legend</span> <span class="o">=</span> <span class="ss">:none</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">2000</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/stationary_densities_22_0.png" src="../_images/stationary_densities_22_0.png" />
</div>
</div>
</div>
</div>
<div class="section" id="appendix">
<h2><a class="toc-backref" href="#id18"><span class="section-number">20.7. </span>Appendix</a><a class="headerlink" href="#appendix" title="Permalink to this headline">¶</a></h2>
<p id="statd-appendix">Here’s the proof of <a class="reference internal" href="#equation-statd-dv">(20.6)</a>.</p>
<p>Let <span class="math notranslate nohighlight">\(F_U\)</span> and <span class="math notranslate nohighlight">\(F_V\)</span> be the cumulative distributions of <span class="math notranslate nohighlight">\(U\)</span> and <span class="math notranslate nohighlight">\(V\)</span> respectively.</p>
<p>By the definition of <span class="math notranslate nohighlight">\(V\)</span>, we have <span class="math notranslate nohighlight">\(F_V(v) = \mathbb P \{ a + b U \leq v \} = \mathbb P \{ U \leq (v - a) / b \}\)</span>.</p>
<p>In other words, <span class="math notranslate nohighlight">\(F_V(v) = F_U ( (v - a)/b )\)</span>.</p>
<p>Differentiating with respect to <span class="math notranslate nohighlight">\(v\)</span> yields <a class="reference internal" href="#equation-statd-dv">(20.6)</a>.</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "julia-1.6"
        },
        kernelOptions: {
            kernelName: "julia-1.6",
            path: "./tools_and_techniques"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'julia-1.6'</script>

                    </div>
                    
                </main> <!-- .page__content -->
                


                <footer class="page__footer">

                    <p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><img src="https://licensebuttons.net/l/by-sa/4.0/80x15.png"></a></p>

                    <p>Creative Commons License &ndash; This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International.</p>

                </footer> <!-- .page__footer -->

            </div> <!-- .page -->

            

            
            <div class="sidebar bd-sidebar inactive" id="site-navigation">

                <div class="sidebar__header">


                    Contents

                </div>

                <nav class="sidebar__nav" id="sidebar-nav" aria-label="Main navigation">
                    <p class="caption">
 <span class="caption-text">
  Getting Started with Julia
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../getting_started_julia/getting_started.html">
   1. Setting up Your Julia Environment
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../getting_started_julia/julia_environment.html">
   2. Interacting with Julia
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../getting_started_julia/julia_by_example.html">
   3. Introductory Examples
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../getting_started_julia/julia_essentials.html">
   4. Julia Essentials
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../getting_started_julia/fundamental_types.html">
   5. Arrays, Tuples, Ranges, and Other Fundamental Types
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../getting_started_julia/introduction_to_types.html">
   6. Introduction to Types and Generic Programming
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Package Ecosystem
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../more_julia/generic_programming.html">
   7. Generic Programming
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../more_julia/general_packages.html">
   8. General Purpose Packages
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../more_julia/data_statistical_packages.html">
   9. Data and Statistics Packages
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../more_julia/optimization_solver_packages.html">
   10. Solvers, Optimizers, and Automatic Differentiation
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Software Engineering
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../software_engineering/tools_editors.html">
   11. Visual Studio Code and other Julia Tools
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../software_engineering/version_control.html">
   12. Git, GitHub, and Version Control
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../software_engineering/testing.html">
   13. Packages, Testing, and Continuous Integration
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../software_engineering/need_for_speed.html">
   14. The Need for Speed
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Tools and Techniques
 </span>
</p>
<ul class="current nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="linear_algebra.html">
   15. Linear Algebra
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="orth_proj.html">
   16. Orthogonal Projections and Their Applications
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lln_clt.html">
   17. LLN and CLT
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="linear_models.html">
   18. Linear State Space Models
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="finite_markov.html">
   19. Finite Markov Chains
  </a>
 </li>
 <li class="toctree-l1 current active active">
  <a class="current reference internal" href="#">
   20. Continuous State Markov Chains
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="kalman.html">
   21. A First Look at the Kalman Filter
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="numerical_linear_algebra.html">
   22. Numerical Linear Algebra and Factorizations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="iterative_methods_sparsity.html">
   23. Krylov Methods and Matrix Conditioning
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Dynamic Programming
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/short_path.html">
   24. Shortest Paths
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/mccall_model.html">
   25. Job Search I: The McCall Search Model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/mccall_model_with_separation.html">
   26. Job Search II: Search and Separation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/wald_friedman.html">
   27. A Problem that Stumped Milton Friedman
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/odu.html">
   28. Job Search III: Search with Learning
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/career.html">
   29. Job Search IV: Modeling Career Choice
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/jv.html">
   30. Job Search V: On-the-Job Search
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/optgrowth.html">
   31. Optimal Growth I: The Stochastic Optimal Growth Model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/coleman_policy_iter.html">
   32. Optimal Growth II: Time Iteration
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/egm_policy_iter.html">
   33. Optimal Growth III: The Endogenous Grid Method
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/lqcontrol.html">
   34. LQ Dynamic Programming Problems
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/perm_income.html">
   35. Optimal Savings I: The Permanent Income Model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/perm_income_cons.html">
   36. Optimal Savings II: LQ Techniques
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/smoothing.html">
   37. Consumption and Tax Smoothing with Complete and Incomplete Markets
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/ifp.html">
   38. Optimal Savings III: Occasionally Binding Constraints
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/robustness.html">
   39. Robustness
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming/discrete_dp.html">
   40. Discrete State Dynamic Programming
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Modeling in Continuous Time
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../continuous_time/seir_model.html">
   41. Modeling COVID 19 with Differential Equations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../continuous_time/covid_sde.html">
   42. Modeling Shocks in COVID 19 with Stochastic Differential Equations
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Multiple Agent Models
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../multi_agent_models/schelling.html">
   43. Schelling’s Segregation Model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../multi_agent_models/lake_model.html">
   44. A Lake Model of Employment and Unemployment
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../multi_agent_models/rational_expectations.html">
   45. Rational Expectations Equilibrium
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../multi_agent_models/markov_perf.html">
   46. Markov Perfect Equilibrium
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../multi_agent_models/markov_asset.html">
   47. Asset Pricing I: Finite State Models
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../multi_agent_models/lucas_model.html">
   48. Asset Pricing II: The Lucas Asset Pricing Model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../multi_agent_models/harrison_kreps.html">
   49. Asset Pricing III:  Incomplete Markets
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../multi_agent_models/uncertainty_traps.html">
   50. Uncertainty Traps
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../multi_agent_models/aiyagari.html">
   51. The Aiyagari Model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../multi_agent_models/arellano.html">
   52. Default Risk and Income Fluctuations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../multi_agent_models/matsuyama.html">
   53. Globalization and Cycles
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Time Series Models
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../time_series_models/arma.html">
   54. Covariance Stationary Processes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../time_series_models/estspec.html">
   55. Estimation of Spectra
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../time_series_models/additive_functionals.html">
   56. Additive Functionals
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../time_series_models/multiplicative_functionals.html">
   57. Multiplicative Functionals
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../time_series_models/lu_tricks.html">
   58. Classical Control with Linear Algebra
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../time_series_models/classical_filtering.html">
   59. Classical Filtering With Linear Algebra
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Dynamic Programming Squared
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming_squared/dyn_stack.html">
   60. Dynamic Stackelberg Problems
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming_squared/lqramsey.html">
   61. Optimal Taxation in an LQ Economy
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming_squared/opt_tax_recur.html">
   62. Optimal Taxation with State-Contingent Debt
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamic_programming_squared/amss.html">
   63. Optimal Taxation without State-Contingent Debt
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Other
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../about_lectures.html">
   64. About these Lectures
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../troubleshooting.html">
   65. Troubleshooting
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../zreferences.html">
   66. References
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../status.html">
   67. Execution Statistics
  </a>
 </li>
</ul>

                </nav>

                <div class="sidebar__footer">

                </div>

            </div> <!-- .sidebar -->
            
        </div> <!-- .main -->

        <div class="toolbar">

            <div class="toolbar__inner">

                <ul class="toolbar__main">
                    <li data-tippy-content="Table of Contents" class="btn__sidebar"><i data-feather="menu"></i></li>
                    <li data-tippy-content="Home"><a href="../intro.html"><i data-feather="home"></i></a></li>
                    <li class="btn__qelogo"><a href="https://quantecon.org" title=""><span class="show-for-sr">QuantEcon</span></a></li>
                    <!-- <li class="btn__search">
                        <form action="../search.html" method="get">
                            <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off">
                            <i data-feather="search"></i>
                        </form>
                    </li> -->
                </ul>

                <ul class="toolbar__links">
                    <li data-tippy-content="Fullscreen" class="btn__fullscreen"><i data-feather="maximize"></i></li>
                    <li data-tippy-content="Increase font size" class="btn__plus"><i data-feather="plus-circle"></i></li>
                    <li data-tippy-content="Decrease font size" class="btn__minus"><i data-feather="minus-circle"></i></li>
                    <li data-tippy-content="Change contrast" class="btn__contrast"><i data-feather="sunset"></i></li>
                    <li data-tippy-content="Download Notebook"><a href="_notebooks/tools_and_techniques/stationary_densities.ipynb" download><i data-feather="download-cloud"></i></a></li>
                    <li class="settings-button" id="settingsButton"><div data-tippy-content="Launch Notebook"><i data-feather="play-circle"></i></div></li>
                        <li data-tippy-content="Download PDF" onClick="window.print()"><i data-feather="file"></i></li>
                    <li data-tippy-content="View Source"><a target="_blank" href="https://github.com/QuantEcon/lecture-julia.myst/tree/master/lectures/tools_and_techniques/stationary_densities.md" download><i data-feather="github"></i></a></li>
                </ul>

            </div>

        </div> <!-- .toolbar -->
        <div id="downloadPDFModal" style="display: none;">
            <ul class="pdf-options" style="display: block;">
                <li class="download-pdf-book" onClick="window.print()">
                    <p>Lecture (PDF)</p>
                </li>
                <li class="download-pdf-file">
                    <a href="" download><p>Book (PDF)</p></a>
                </li>
            </ul>
        </div>
        <div id="settingsModal" style="display: none;">
            <p class="modal-title"> Notebook Launcher </p>
            <div class="modal-desc">
            <p>
                Choose public or private cloud service for "Launch" button.
            </p>
            </div>
            <p class="modal-subtitle">Select a server</p>
            <ul class="modal-servers">
            <li class="active launcher-public">
                <span class="label">Public</span>
                <select id="launcher-public-input">
                
                    <option value="https://mybinder.org/v2/gh/QuantEcon/lecture-julia.notebooks/master?urlpath=tree/tools_and_techniques/stationary_densities.ipynb">BinderHub</option>
                
                </select>
                <i class="fas fa-check-circle"></i>
            </li>
            <li class="launcher-private">
                <span class="label">Private</span>
                <input type="text" id="launcher-private-input" data-repourl="https://github.com/QuantEcon/lecture-julia.notebooks" data-urlpath="tree/lecture-julia.notebooks/tools_and_techniques/stationary_densities.ipynb" data-branch=master>
                <i class="fas fa-check-circle"></i>
            </li>
            </ul>
            <p class="launch"><a href="https://mybinder.org/v2/gh/QuantEcon/lecture-julia.notebooks/master?urlpath=tree/tools_and_techniques/stationary_densities.ipynb" id="advancedLaunchButton" target="_blank">Launch Notebook</a></p>
            <script>
                // QuantEcon Notebook Launcher
                const launcherTypeElements = document.querySelectorAll('#settingsModal .modal-servers li');
                // Highlight the server type if previous selection exists
                if (typeof localStorage.launcherType !== 'undefined') {
                  for (var i = 0; i < launcherTypeElements.length; i++) {
                    launcherTypeElements[i].classList.remove('active');
                    if ( launcherTypeElements[i].classList.contains(localStorage.launcherType) ) {
                      launcherTypeElements[i].classList.add('active');
                    }
                  }
                }
                // Highlight server type on click and set local storage value
                for (var i = 0; i < launcherTypeElements.length; i++) {
                  launcherTypeElements[i].addEventListener('click', function() {
                    for (var j = 0; j < launcherTypeElements.length; j++) {
                      launcherTypeElements[j].classList.remove('active');
                    }
                    this.classList.add('active');
                    if ( this.classList.contains('launcher-private') ) {
                      localStorage.launcherType = 'launcher-private';
                    } else if ( this.classList.contains('launcher-public') ) {
                      localStorage.launcherType = 'launcher-public';
                    }
                    setLaunchServer();
                  })
                }
                const launcherPublic = document.getElementById('launcher-public-input');
                const launcherPrivate = document.getElementById('launcher-private-input');
                const pageName = "tools_and_techniques/stationary_densities";
                const repoURL = "https://github.com/QuantEcon/lecture-julia.notebooks";
                const urlPath = "tree/lecture-julia.notebooks/tools_and_techniques/stationary_densities.ipynb";
                const branch = "master"
                const launchNotebookLink = document.getElementById('advancedLaunchButton');

                // Highlight public server option if previous selection exists
                if (typeof localStorage.launcherPublic !== 'undefined') {
                  launcherPublic.value = localStorage.launcherPublic;
                }
                // Update local storage upon public server selection
                launcherPublic.addEventListener('change', (event) => {
                  setLaunchServer();
                });
                // Populate private server input if previous entry exists
                if (typeof localStorage.launcherPrivate !== 'undefined') {
                  launcherPrivate.value = localStorage.launcherPrivate;
                }
                // Update local storage when a private server is entered
                launcherPrivate.addEventListener('input', (event) => {
                  setLaunchServer();
                });

                // Function to update the "Launch Notebook" link href
                function setLaunchServer() {
                  launchNotebookLink.removeAttribute("style")
                  if ( localStorage.launcherType == 'launcher-private' ) {
                    let repoPrefix = "/jupyter/hub/user-redirect/git-pull?repo=" + repoURL + "&branch=" + branch + "&urlpath=" + urlPath;
                    launcherPrivateValue = launcherPrivate.value
                    if (!launcherPrivateValue) {
                        launchNotebookLink.removeAttribute("href")
                        launchNotebookLink.style.background = "grey"
                        return
                    }
                    localStorage.launcherPrivate = launcherPrivateValue;
                    privateServer = localStorage.launcherPrivate.replace(/\/$/, "")
                    if (!privateServer.includes("http")) {
                        privateServer = "http://" + privateServer
                    }
                    launchNotebookLinkURL = privateServer + repoPrefix;
                  } else if ( localStorage.launcherType == 'launcher-public' ) {
                    launcherPublicValue = launcherPublic.options[launcherPublic.selectedIndex].value;
                    localStorage.launcherPublic = launcherPublicValue;
                    launchNotebookLinkURL = localStorage.launcherPublic;
                  }
                  if (launchNotebookLinkURL) launchNotebookLink.href = launchNotebookLinkURL;
                }
                // Check if user has previously selected a server
                if ( (typeof localStorage.launcherPrivate !== 'undefined') || (typeof localStorage.launcherPublic !== 'undefined') ) {
                  setLaunchServer();
                }
                </script>

        </div>

    </div> <!-- .wrapper-->
    
<script async="" src="https://www.google-analytics.com/analytics.js"></script>
<script>
                        window.ga = window.ga || function () {
                            (ga.q = ga.q || []).push(arguments) };
                        ga.l = +new Date;
                        ga('create', 'UA-54984338-8', 'auto');
                        ga('set', 'anonymizeIp', true);
                        ga('send', 'pageview');
                    </script>

  </body>
</html>